{"version":3,"sources":["node_modules/browser-pack/_prelude.js","orator.min.js","node_modules/assert/assert.js","node_modules/assert/node_modules/inherits/inherits_browser.js","node_modules/assert/node_modules/util/support/isBufferBrowser.js","node_modules/assert/node_modules/util/util.js","node_modules/async/asyncify.js","node_modules/async/eachOfLimit.js","node_modules/async/eachofseries.js","node_modules/async/internal/asyncEachOfLimit.js","node_modules/async/internal/awaitify.js","node_modules/async/internal/breakLoop.js","node_modules/async/internal/eachOfLimit.js","node_modules/async/internal/getIterator.js","node_modules/async/internal/initialParams.js","node_modules/async/internal/isArrayLike.js","node_modules/async/internal/iterator.js","node_modules/async/internal/once.js","node_modules/async/internal/onlyOnce.js","node_modules/async/internal/setImmediate.js","node_modules/async/internal/wrapAsync.js","node_modules/async/waterfall.js","node_modules/fable-log/source/Fable-Log-BaseLogger.js","node_modules/fable-log/source/Fable-Log-DefaultProviders-Web.js","node_modules/fable-log/source/Fable-Log-DefaultStreams.json","node_modules/fable-log/source/Fable-Log-Logger-Console.js","node_modules/fable-log/source/Fable-Log.js","node_modules/fable-settings/source/Fable-Settings-Default.json","node_modules/fable-settings/source/Fable-Settings-TemplateProcessor.js","node_modules/fable-settings/source/Fable-Settings.js","node_modules/fable-uuid/source/Fable-UUID-Random-Browser.js","node_modules/fable-uuid/source/Fable-UUID.js","node_modules/fable/source/Fable.js","node_modules/fast-decode-uri-component/index.js","node_modules/fast-deep-equal/index.js","node_modules/fast-querystring/lib/index.js","node_modules/fast-querystring/lib/internals/querystring.js","node_modules/fast-querystring/lib/parse.js","node_modules/fast-querystring/lib/stringify.js","node_modules/find-my-way/custom_node.js","node_modules/find-my-way/handler_storage.js","node_modules/find-my-way/index.js","node_modules/find-my-way/lib/constrainer.js","node_modules/find-my-way/lib/http-methods.js","node_modules/find-my-way/lib/pretty-print.js","node_modules/find-my-way/lib/strategies/accept-host.js","node_modules/find-my-way/lib/strategies/accept-version.js","node_modules/find-my-way/lib/url-sanitizer.js","node_modules/object-assign/index.js","node_modules/orator-serviceserver/source/Orator-ServiceServer.js","node_modules/precedent/source/Precedent.js","node_modules/precedent/source/StringParser.js","node_modules/precedent/source/WordTree.js","node_modules/process/browser.js","node_modules/safe-regex2/index.js","node_modules/safe-regex2/node_modules/ret/lib/index.js","node_modules/safe-regex2/node_modules/ret/lib/positions.js","node_modules/safe-regex2/node_modules/ret/lib/sets.js","node_modules/safe-regex2/node_modules/ret/lib/types.js","node_modules/safe-regex2/node_modules/ret/lib/util.js","node_modules/timers-browserify/main.js","source/Orator-Browser-Shim.js","source/Orator-Default-Configuration.js","source/Orator-Default-ServiceServers-Web.js","source/Orator-ServiceServer-IPC-RouterConstrainer.js","source/Orator-ServiceServer-IPC-SynthesizedResponse.js","source/Orator-ServiceServer-IPC.js","source/Orator.js"],"names":["f","exports","module","define","amd","window","global","self","this","Orator","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","objectAssign","compare","b","x","y","len","Math","min","isBuffer","Buffer","_isBuffer","util","hasOwn","Object","prototype","hasOwnProperty","pSlice","Array","slice","functionsHaveNames","name","pToString","obj","toString","isView","arrbuf","ArrayBuffer","DataView","buffer","assert","ok","regex","getName","func","isFunction","match","truncate","s","inspect","something","rawname","fail","actual","expected","message","operator","stackStartFunction","AssertionError","value","_deepEqual","strict","memos","isDate","getTime","isRegExp","source","multiline","lastIndex","ignoreCase","Float32Array","Float64Array","Uint8Array","actualIndex","indexOf","push","actualVisitedObjects","isPrimitive","getPrototypeOf","aIsArgs","isArguments","bIsArgs","key","ka","objectKeys","kb","sort","objEquiv","object","expectedException","test","isPrototypeOf","_throws","shouldThrow","block","TypeError","error","_tryBlock","userProvidedMessage","isUnexpectedException","isError","options","generatedMessage","getMessage","captureStackTrace","err","stack","out","fn_name","idx","next_line","substring","inherits","equal","notEqual","deepEqual","deepStrictEqual","notDeepEqual","notDeepStrictEqual","strictEqual","notStrictEqual","throws","doesNotThrow","ifError","keys","create","ctor","superCtor","super_","constructor","enumerable","writable","configurable","TempCtor","arg","copy","fill","readUInt8","process","formatRegExp","format","isString","objects","arguments","join","args","str","String","replace","Number","JSON","stringify","_","isNull","isObject","deprecate","fn","msg","isUndefined","apply","noDeprecation","warned","throwDeprecation","traceDeprecation","console","trace","debugEnviron","debugs","opts","ctx","seen","stylize","stylizeNoColor","depth","colors","isBoolean","showHidden","_extend","customInspect","stylizeWithColor","formatValue","styleType","style","styles","recurseTimes","ret","primitive","simple","isNumber","formatPrimitive","visibleKeys","array","hash","forEach","val","arrayToHash","getOwnPropertyNames","formatError","RegExp","Date","output","base","braces","isArray","toUTCString","l","formatProperty","formatArray","map","pop","reduce","prev","cur","numLinesEst","reduceToSingleString","desc","getOwnPropertyDescriptor","get","set","split","line","substr","ar","re","objectToString","d","pad","debuglog","env","NODE_DEBUG","toUpperCase","pid","bold","italic","underline","inverse","white","grey","black","blue","cyan","green","magenta","red","yellow","special","number","boolean","undefined","null","string","date","regexp","isNullOrUndefined","isSymbol","months","prop","log","time","getHours","getMinutes","getSeconds","getDate","getMonth","origin","add","_process","defineProperty","default","_wrapAsync","isAsync","callback","handlePromise","_initialParams2","result","then","_interopRequireDefault","_setImmediate2","__esModule","promise","invokeCallback","_eachOfLimit3","_wrapAsync2","_awaitify2","coll","limit","iteratee","_eachOfLimit2","generator","done","canceled","awaiting","running","replenish","next","iterDone","iterateeCallback","catch","handleError","_breakLoop2","_breakLoop","asyncFn","arity","Promise","resolve","reject","cbArgs","_once2","_iterator2","_onlyOnce2","_asyncEachOfLimit2","RangeError","isAsyncGenerator","isAsyncIterable","Symbol","asyncIterator","nextElem","looping","elem","iterator","_isArrayLike2","createArrayIterator","_getIterator2","item","createES2015Iterator","okeys","wrapper","callFn","assign","setImmediate","fallback","wrap","_defer","hasQueueMicrotask","queueMicrotask","hasSetImmediate","hasNextTick","nextTick","setTimeout","defer","timers","_asyncify","_asyncify2","toStringTag","tasks","taskIndex","nextTask","task","pLogStreamSettings","pFableLog","_Settings","loggerUUID","generateInsecureUUID","levels","tmpDate","pCharacter","tmpRandomData","random","floor","initialize","pLogText","pLogObject","write","debug","info","warn","fatal","pLogLevel","getDefaultProviders","tmpDefaultProviders","loggertype","streamtype","level","libBaseLogger","super","_ShowTimeStamps","showtimestamps","_FormattedTimeStamps","formattedtimestamps","_ContextMessage","Context","Product","_OutputLogLinesToConsole","outputloglinestoconsole","_OutputObjectsToConsole","outputobjectstoconsole","prefixCache","pLevel","pObject","tmpTimeStamp","toISOString","tmpLogLine","FableLog","pFableSettings","pFable","tmpSettings","_Providers","_StreamDefinitions","LogStreams","logStreams","logProviders","activeLogStreams","logStreamsTrace","logStreamsDebug","logStreamsInfo","logStreamsWarn","logStreamsError","logStreamsFatal","datumDecorator","pDatum","uuid","addLogger","pLogger","setDatumDecorator","fDatumDecorator","pMessage","tmpDecoratedDatum","tmpStreamDefinition","logTime","tmpMessage","tmpTime","getTimeStamp","getTimeDelta","pTimeStamp","logTimeDelta","pTimeDelta","tmpEndTime","logTimeDeltaHuman","tmpMs","parseInt","tmpSeconds","tmpMinutes","tmpHours","logTimeDeltaRelative","pStartTime","logTimeDeltaRelativeHuman","new","pSettings","ProductVersion","ConfigFile","pDependencies","templateProcessor","precedent","addPattern","pTemplateValue","tmpTemplateValue","trim","tmpSeparatorIndex","tmpDefaultValue","tmpEnvironmentVariableName","parseSetting","pString","parseString","libPrecedent","libFableSettingsTemplateProcessor","FableSettings","dependencies","settingsTemplateProcessor","_configureEnvTemplating","buildDefaultSettings","merge","parse","DefaultConfigFile","pException","settings","_PerformEnvTemplating","NoEnvReplacement","_resolveEnv","tmpKey","_isObject","_deepMergeObjects","toObject","fromObject","fromValue","toValue","pSettingsFrom","pSettingsTo","tmpSettingsFrom","tmpSettingsTo","tmpSettingsFromCopy","getRandomValues","crypto","bind","msCrypto","generateWhatWGBytes","tmpBuffer","generateRandomBytes","tmpValue","generate","libRandomByteGenerator","FableUUID","_UUIDModeRandom","UUIDModeRandom","_UUIDLength","UUIDLength","_UUIDRandomDictionary","UUIDDictionary","randomByteGenerator","_HexLookup","bytesToUUID","pBuffer","generateUUIDv4","tmpRandomBytes","generateRandom","tmpUUID","charAt","getUUID","libFableSettings","libFableUUID","libFableLog","Fable","settingsManager","libUUID","fable","UTF8_ACCEPT","UTF8_REJECT","UTF8_DATA","HEX","A","B","C","D","E","F","hexCodeToInt","shift","uri","percentPosition","decoded","last","codepoint","startOfOctets","state","byte","type","charCodeAt","fromCharCode","flags","valueOf","fastQuerystring","hexTable","from","noEscape","Int8Array","encodeString","lastPos","outer","fastDecode","plusRegex","Empty","input","inputLength","startingIndex","equalityIndex","shouldDecodeKey","shouldDecodeValue","keyHasPlus","valueHasPlus","hasBothKeyValuePair","currentValue","getAsPrimitive","isFinite","keyLength","valueLength","encodedKey","j","HandlerStorage","NODE_TYPES","STATIC","PARAMETRIC","WILDCARD","Node","handlerStorage","ParentNode","staticChildren","findStaticMatchingChild","path","pathIndex","staticChild","matchPrefix","createStaticChild","prefix","label","StaticNode","wildcardChild","parametricChildren","kind","_compilePrefixMatch","createParametricChild","staticSuffix","regexpSource","parametricChild","find","child","ParametricNode","child1","child2","isRegex","endsWith","createWildcardChild","WildcardNode","parentNode","parentPrefix","childPrefix","staticNode","getNextNode","nodeStack","paramsCount","node","parametricBrotherNodeIndex","brotherPathIndex","brotherNode","lines","charCode","Function","unconstrainedHandler","constraints","handlers","constrainedHandlerStores","getMatchingHandler","derivedConstraints","_getHandlerMatchingConstraints","addHandler","handler","params","store","constrainer","handlerObject","_createParamsObject","_compileCreateParamsObject","constraint","includes","unshift","_compileGetHandlerMatchingConstraints","_buildConstraintStore","constraintValue","indexes","_constrainedIndexBitmask","mask","newStoreForConstraint","matchMask","strategies","mustMatchWhenDerived","querystring","isRegexSafe","flattenNode","compressFlattenedNode","prettyPrintFlattenedNode","prettyPrintRoutesArray","Constrainer","httpMethods","safeDecodeURI","safeDecodeURIComponent","FULL_PATH_REGEXP","OPTIONAL_PARAM_REGEXP","Router","defaultRoute","onBadUrl","buildPrettyMeta","defaultBuildPrettyMeta","querystringParser","query","caseSensitive","ignoreTrailingSlash","ignoreDuplicateSlashes","maxParamLength","allowUnsafeRegex","routes","trees","_routesPatterns","on","method","optionalParamMatch","index","pathFull","pathOptional","route","removeDuplicateSlashes","trimLastSlash","methods","_on","validateConstraints","noteUsage","currentRoot","currentNode","parentNodePathIndex","isParametricNode","isWildcardNode","staticNodePath","toLowerCase","isRegexNode","regexps","lastParamStartIndex","isRegexParam","isStaticPart","isEndOfNode","paramName","endOfRegexIndex","getClosingParenthensePosition","regexString","trimRegExpStartAndEnd","staticPartStartIndex","staticPart","nodePattern","existRoute","hasConstraintStrategy","strategyName","addConstraintStrategy","_rebuild","reset","off","_off","matcherWithoutConstraints","predicate","newRoutes","filter","lookup","req","res","deriveConstraints","handle","url","callHandler","_defaultRoute","searchParams","sanitizedUrl","shouldDecodeParam","_onBadUrl","originPath","pathLen","brothersNodesStack","brotherNodeState","splice","paramEndIndex","param","matchedParameters","exec","matchedParam","statusCode","end","prettyPrint","commonPrefix","root","nodes","children","m","methodName","parentheses","all","acceptVersionStrategy","acceptHostStrategy","customStrategies","version","host","strategiesInUse","Set","asyncStrategiesInUse","strategy","values","isStrategyUsed","has","customConstraintStrategy","isCustom","storage","deriveConstraint","deriveSyncConstraints","deriveAsyncConstraints","beforeSize","size","_buildDeriveConstraints","validate","asyncConstraintsCount","indent","branchIndent","midBranchIndent","endBranchIndent","wildcardDelimiter","pathDelimiter","pathRegExp","parseMeta","meta","fName","parseFunctionName","buildMetaObject","metaArray","cleanMeta","Reflect","ownKeys","metaKey","drawBranch","pathSeg","endBranch","noPrefix","rootBranch","branch","flatHandlers","acc","curr","findIndex","h","hidx","skipPrefix","flattened","childPrefixSegments","parent","cursor","segment","flattenedNode","childKeys","tail","includeMeta","printHandlers","suffix","paramIndices","ch","prevLoc","loc","tree","labels","routeArray","mergedRouteArray","localeCompare","pathExists","routeHandler","rootPath","truncatedPath","routeTree","temp","splitPath","pidx","buildRouteTree","hosts","regexHosts","exact","SemVerStore","maxMajor","maxMinors","maxPatches","major","minor","patch","decodeComponentChar","highCharCode","lowCharCode","shouldDecode","decodeURI","uriComponent","startIndex","decodedChar","getOwnPropertySymbols","propIsEnumerable","propertyIsEnumerable","test1","test2","test3","letter","shouldUseNative","target","symbols","to","pOrator","orator","Name","URL","Port","ServicePort","Active","listen","pPort","fCallback","close","pRoute","fRouteProcessingFunctions","put","post","del","head","invoke","pMethod","pData","libWordTree","libStringParser","WordTree","StringParser","ParseTree","pPatternStart","pPatternEnd","pParser","newParserState","pParseTree","Output","OutputBuffer","Pattern","PatternMatch","PatternMatchOutputBuffer","assignNode","pNode","pParserState","appendOutputBuffer","flushOutputBuffer","checkPatternEnd","PatternEnd","PatternStart","Parse","parseCharacter","tmpParserState","addChild","pTree","pPattern","pIndex","tmpLeaf","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","run","marker","runClearTimeout","Item","noop","title","browser","argv","versions","addListener","once","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","types","replimit","reps","walk","starHeight","REPETITION","sets","positions","regexpStr","start","ROOT","lastGroup","groupStack","repeatErr","strToChars","wordBoundary","nonWordBoundary","words","notWords","ints","notInts","whitespace","notWhitespace","REFERENCE","CHAR","begin","not","classTokens","tokenizeClass","SET","anyChar","group","GROUP","remember","followedBy","notFollowedBy","max","rs","Infinity","POSITION","INTS","RANGE","WORDS","WHITESPACE","SLSH","v","lbs","a16","b16","c8","dctrl","eslsh","tokens","SyntaxError","clearImmediate","immediateIds","nextImmediateId","Timeout","id","clearFn","_id","_clearFn","setInterval","clearInterval","unref","ref","enroll","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","libNPMModuleWrapper","getDefaultServiceServers","tmpDefaultServiceServers","ipc","pRequest","pContext","fDone","pLog","pRequestGUID","requestGUID","responseData","responseStatus","send","libOratorServiceServerBase","libOratorServiceServerIPCSynthesizedResponse","libOratorServiceServerIPCCustomConstrainer","libFindMyWay","libAsyncWaterfall","libAsyncEachOfSeries","routerOptions","router_options","router","preBehaviorFunctions","behaviorMap","postBehaviorFunctions","executePreBehaviorFunctions","pResponse","fNext","fBehaviorFunction","pFunctionIndex","pError","executePostBehaviorFunctions","addRouteProcessor","pRouteFunctionArray","pParameters","fStageComplete","pBehaviorFunctionError","pRequestError","tmpCallback","tmpRequest","guid","tmpSynthesizedResponseData","pResults","Route","Data","libFable","defaultOratorConfiguration","defaultOratorServiceServers","pServiceProvider","serviceServer","serviceServerProvider","APIServerPort","initializeServiceServer","webServer","_startServiceListener","startService","tmpNext","stopService","startWebServer","stopWebServer","getWebServer"],"mappings":"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AAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAIA,E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","file":"orator.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Orator = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n(function (global){(function (){\n'use strict';\n\nvar objectAssign = require('object-assign');\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n// NB: The URL to the CommonJS spec is kept just for tradition.\n//     node-assert has evolved a lot since then, both in API and behavior.\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util/');\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\n// Expose a strict only variant of assert\nfunction strict(value, message) {\n  if (!value) fail(value, true, message, '==', strict);\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"object-assign\":47,\"util/\":4}],2:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],3:[function(require,module,exports){\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n},{}],4:[function(require,module,exports){\n(function (process,global){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./support/isBuffer\":3,\"_process\":52,\"inherits\":2}],5:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = asyncify;\n\nvar _initialParams = require('./internal/initialParams.js');\n\nvar _initialParams2 = _interopRequireDefault(_initialParams);\n\nvar _setImmediate = require('./internal/setImmediate.js');\n\nvar _setImmediate2 = _interopRequireDefault(_setImmediate);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    if ((0, _wrapAsync.isAsync)(func)) {\n        return function (...args /*, callback*/) {\n            const callback = args.pop();\n            const promise = func.apply(this, args);\n            return handlePromise(promise, callback);\n        };\n    }\n\n    return (0, _initialParams2.default)(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (result && typeof result.then === 'function') {\n            return handlePromise(result, callback);\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nfunction handlePromise(promise, callback) {\n    return promise.then(value => {\n        invokeCallback(callback, null, value);\n    }, err => {\n        invokeCallback(callback, err && err.message ? err : new Error(err));\n    });\n}\n\nfunction invokeCallback(callback, error, value) {\n    try {\n        callback(error, value);\n    } catch (err) {\n        (0, _setImmediate2.default)(e => {\n            throw e;\n        }, err);\n    }\n}\nmodule.exports = exports['default'];\n},{\"./internal/initialParams.js\":13,\"./internal/setImmediate.js\":18,\"./internal/wrapAsync.js\":19}],6:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _eachOfLimit2 = require('./internal/eachOfLimit.js');\n\nvar _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _awaitify = require('./internal/awaitify.js');\n\nvar _awaitify2 = _interopRequireDefault(_awaitify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name eachOfLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachOfLimit(coll, limit, iteratee, callback) {\n  return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);\n}\n\nexports.default = (0, _awaitify2.default)(eachOfLimit, 4);\nmodule.exports = exports['default'];\n},{\"./internal/awaitify.js\":9,\"./internal/eachOfLimit.js\":11,\"./internal/wrapAsync.js\":19}],7:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _eachOfLimit = require('./eachOfLimit.js');\n\nvar _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);\n\nvar _awaitify = require('./internal/awaitify.js');\n\nvar _awaitify2 = _interopRequireDefault(_awaitify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n *\n * @name eachOfSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfSeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachOfSeries(coll, iteratee, callback) {\n  return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);\n}\nexports.default = (0, _awaitify2.default)(eachOfSeries, 3);\nmodule.exports = exports['default'];\n},{\"./eachOfLimit.js\":6,\"./internal/awaitify.js\":9}],8:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = asyncEachOfLimit;\n\nvar _breakLoop = require('./breakLoop.js');\n\nvar _breakLoop2 = _interopRequireDefault(_breakLoop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// for async generators\nfunction asyncEachOfLimit(generator, limit, iteratee, callback) {\n    let done = false;\n    let canceled = false;\n    let awaiting = false;\n    let running = 0;\n    let idx = 0;\n\n    function replenish() {\n        //console.log('replenish')\n        if (running >= limit || awaiting || done) return;\n        //console.log('replenish awaiting')\n        awaiting = true;\n        generator.next().then(({ value, done: iterDone }) => {\n            //console.log('got value', value)\n            if (canceled || done) return;\n            awaiting = false;\n            if (iterDone) {\n                done = true;\n                if (running <= 0) {\n                    //console.log('done nextCb')\n                    callback(null);\n                }\n                return;\n            }\n            running++;\n            iteratee(value, idx, iterateeCallback);\n            idx++;\n            replenish();\n        }).catch(handleError);\n    }\n\n    function iterateeCallback(err, result) {\n        //console.log('iterateeCallback')\n        running -= 1;\n        if (canceled) return;\n        if (err) return handleError(err);\n\n        if (err === false) {\n            done = true;\n            canceled = true;\n            return;\n        }\n\n        if (result === _breakLoop2.default || done && running <= 0) {\n            done = true;\n            //console.log('done iterCb')\n            return callback(null);\n        }\n        replenish();\n    }\n\n    function handleError(err) {\n        if (canceled) return;\n        awaiting = false;\n        done = true;\n        callback(err);\n    }\n\n    replenish();\n}\nmodule.exports = exports['default'];\n},{\"./breakLoop.js\":10}],9:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = awaitify;\n// conditionally promisify a function.\n// only return a promise if a callback is omitted\nfunction awaitify(asyncFn, arity = asyncFn.length) {\n    if (!arity) throw new Error('arity is undefined');\n    function awaitable(...args) {\n        if (typeof args[arity - 1] === 'function') {\n            return asyncFn.apply(this, args);\n        }\n\n        return new Promise((resolve, reject) => {\n            args[arity - 1] = (err, ...cbArgs) => {\n                if (err) return reject(err);\n                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);\n            };\n            asyncFn.apply(this, args);\n        });\n    }\n\n    return awaitable;\n}\nmodule.exports = exports['default'];\n},{}],10:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nconst breakLoop = {};\nexports.default = breakLoop;\nmodule.exports = exports[\"default\"];\n},{}],11:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _once = require('./once.js');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _iterator = require('./iterator.js');\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _onlyOnce = require('./onlyOnce.js');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./wrapAsync.js');\n\nvar _asyncEachOfLimit = require('./asyncEachOfLimit.js');\n\nvar _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);\n\nvar _breakLoop = require('./breakLoop.js');\n\nvar _breakLoop2 = _interopRequireDefault(_breakLoop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = limit => {\n    return (obj, iteratee, callback) => {\n        callback = (0, _once2.default)(callback);\n        if (limit <= 0) {\n            throw new RangeError('concurrency limit cannot be less than 1');\n        }\n        if (!obj) {\n            return callback(null);\n        }\n        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {\n            return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);\n        }\n        if ((0, _wrapAsync.isAsyncIterable)(obj)) {\n            return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);\n        }\n        var nextElem = (0, _iterator2.default)(obj);\n        var done = false;\n        var canceled = false;\n        var running = 0;\n        var looping = false;\n\n        function iterateeCallback(err, value) {\n            if (canceled) return;\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            } else if (err === false) {\n                done = true;\n                canceled = true;\n            } else if (value === _breakLoop2.default || done && running <= 0) {\n                done = true;\n                return callback(null);\n            } else if (!looping) {\n                replenish();\n            }\n        }\n\n        function replenish() {\n            looping = true;\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));\n            }\n            looping = false;\n        }\n\n        replenish();\n    };\n};\n\nmodule.exports = exports['default'];\n},{\"./asyncEachOfLimit.js\":8,\"./breakLoop.js\":10,\"./iterator.js\":15,\"./once.js\":16,\"./onlyOnce.js\":17,\"./wrapAsync.js\":19}],12:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (coll) {\n    return coll[Symbol.iterator] && coll[Symbol.iterator]();\n};\n\nmodule.exports = exports[\"default\"];\n},{}],13:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (fn) {\n    return function (...args /*, callback*/) {\n        var callback = args.pop();\n        return fn.call(this, args, callback);\n    };\n};\n\nmodule.exports = exports[\"default\"];\n},{}],14:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = isArrayLike;\nfunction isArrayLike(value) {\n    return value && typeof value.length === 'number' && value.length >= 0 && value.length % 1 === 0;\n}\nmodule.exports = exports['default'];\n},{}],15:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = createIterator;\n\nvar _isArrayLike = require('./isArrayLike.js');\n\nvar _isArrayLike2 = _interopRequireDefault(_isArrayLike);\n\nvar _getIterator = require('./getIterator.js');\n\nvar _getIterator2 = _interopRequireDefault(_getIterator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? { value: coll[i], key: i } : null;\n    };\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done) return null;\n        i++;\n        return { value: item.value, key: i };\n    };\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = obj ? Object.keys(obj) : [];\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        if (key === '__proto__') {\n            return next();\n        }\n        return i < len ? { value: obj[key], key } : null;\n    };\n}\n\nfunction createIterator(coll) {\n    if ((0, _isArrayLike2.default)(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = (0, _getIterator2.default)(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\nmodule.exports = exports['default'];\n},{\"./getIterator.js\":12,\"./isArrayLike.js\":14}],16:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = once;\nfunction once(fn) {\n    function wrapper(...args) {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    }\n    Object.assign(wrapper, fn);\n    return wrapper;\n}\nmodule.exports = exports[\"default\"];\n},{}],17:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = onlyOnce;\nfunction onlyOnce(fn) {\n    return function (...args) {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    };\n}\nmodule.exports = exports[\"default\"];\n},{}],18:[function(require,module,exports){\n(function (process,setImmediate){(function (){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.fallback = fallback;\nexports.wrap = wrap;\n/* istanbul ignore file */\n\nvar hasQueueMicrotask = exports.hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;\nvar hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return (fn, ...args) => defer(() => fn(...args));\n}\n\nvar _defer;\n\nif (hasQueueMicrotask) {\n    _defer = queueMicrotask;\n} else if (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nexports.default = wrap(_defer);\n}).call(this)}).call(this,require('_process'),require(\"timers\").setImmediate)\n\n},{\"_process\":52,\"timers\":59}],19:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = undefined;\n\nvar _asyncify = require('../asyncify.js');\n\nvar _asyncify2 = _interopRequireDefault(_asyncify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isAsync(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction isAsyncGenerator(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncGenerator';\n}\n\nfunction isAsyncIterable(obj) {\n    return typeof obj[Symbol.asyncIterator] === 'function';\n}\n\nfunction wrapAsync(asyncFn) {\n    if (typeof asyncFn !== 'function') throw new Error('expected a function');\n    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;\n}\n\nexports.default = wrapAsync;\nexports.isAsync = isAsync;\nexports.isAsyncGenerator = isAsyncGenerator;\nexports.isAsyncIterable = isAsyncIterable;\n},{\"../asyncify.js\":5}],20:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _once = require('./internal/once.js');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _onlyOnce = require('./internal/onlyOnce.js');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _awaitify = require('./internal/awaitify.js');\n\nvar _awaitify2 = _interopRequireDefault(_awaitify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nfunction waterfall(tasks, callback) {\n    callback = (0, _once2.default)(callback);\n    if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);\n        task(...args, (0, _onlyOnce2.default)(next));\n    }\n\n    function next(err, ...args) {\n        if (err === false) return;\n        if (err || taskIndex === tasks.length) {\n            return callback(err, ...args);\n        }\n        nextTask(args);\n    }\n\n    nextTask([]);\n}\n\nexports.default = (0, _awaitify2.default)(waterfall);\nmodule.exports = exports['default'];\n},{\"./internal/awaitify.js\":9,\"./internal/once.js\":16,\"./internal/onlyOnce.js\":17,\"./internal/wrapAsync.js\":19}],21:[function(require,module,exports){\n/**\n* Base Logger Class\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nclass BaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = pLogStreamSettings;\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n\n},{}],22:[function(require,module,exports){\n/**\n* Default Logger Provider Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\ngetDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();\n},{\"./Fable-Log-Logger-Console.js\":24}],23:[function(require,module,exports){\nmodule.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]\n},{}],24:[function(require,module,exports){\nlet libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = pLogStreamSettings.hasOwnProperty('showtimestamps') ? (pLogStreamSettings.showtimestamps == true) : false;\n\t\tthis._FormattedTimeStamps = pLogStreamSettings.hasOwnProperty('formattedtimestamps') ? (pLogStreamSettings.formattedtimestamps == true) : false;\n\n\t\tthis._ContextMessage = pLogStreamSettings.hasOwnProperty('Context') ? `(${pLogStreamSettings.Context})` : \n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = pLogStreamSettings.hasOwnProperty('outputloglinestoconsole') ? pLogStreamSettings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = pLogStreamSettings.hasOwnProperty('outputobjectstoconsole') ? pLogStreamSettings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;\n},{\"./Fable-Log-BaseLogger.js\":21}],25:[function(require,module,exports){\n/**\n* Fable Logging Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Logger\n*/\n\n/**\n* Fable Solution Log Wrapper Main Class\n*\n* @class FableLog\n* @constructor\n*/\nclass FableLog\n{\n\tconstructor(pFableSettings, pFable)\n\t{\n\t\tlet tmpSettings = (typeof(pFableSettings) === 'object') ? pFableSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableLog(pSettings);\n}\n\n\nmodule.exports = {new:autoConstruct, FableLog:FableLog};\n\n},{\"./Fable-Log-DefaultProviders-Node.js\":22,\"./Fable-Log-DefaultStreams.json\":23}],26:[function(require,module,exports){\nmodule.exports={\n\t\"Product\": \"ApplicationNameHere\",\n\t\"ProductVersion\": \"0.0.0\",\n\n\t\"ConfigFile\": false,\n\n\t\"LogStreams\":\n\t[\n\t\t{\n\t\t\t\"level\": \"trace\"\n\t\t}\n\t]\n}\n\n},{}],27:[function(require,module,exports){\n(function (process){(function (){\n/**\n* Fable Settings Template Processor\n*\n* This class allows environment variables to come in via templated expressions, and defaults to be set.\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nclass FableSettingsTemplateProcessor\n{\n\tconstructor(pDependencies)\n\t{\n        // Use a no-dependencies templating engine to parse out environment variables\n\t\tthis.templateProcessor = new pDependencies.precedent();\n\n        // TODO: Make the environment variable wrap expression demarcation characters configurable?\n\t\tthis.templateProcessor.addPattern('${', '}',\n\t\t\t(pTemplateValue)=>\n\t\t\t{\n\t\t\t\tlet tmpTemplateValue = pTemplateValue.trim();\n\n\t\t\t\tlet tmpSeparatorIndex = tmpTemplateValue.indexOf('|');\n\n\t\t\t\t// If there is no pipe, the default value will end up being whatever the variable name is.\n\t\t\t\tlet tmpDefaultValue = tmpTemplateValue.substring(tmpSeparatorIndex+1);\n\n\t\t\t\tlet tmpEnvironmentVariableName = (tmpSeparatorIndex > -1) ? tmpTemplateValue.substring(0, tmpSeparatorIndex) : tmpTemplateValue;\n\n\t\t\t\tif (process.env.hasOwnProperty(tmpEnvironmentVariableName))\n\t\t\t\t{\n\t\t\t\t\treturn process.env[tmpEnvironmentVariableName];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpDefaultValue;\n\t\t\t\t}\n\t\t\t});\n    }\n\n    parseSetting(pString)\n    {\n        return this.templateProcessor.parseString(pString);\n    }\n}\n\nmodule.exports = FableSettingsTemplateProcessor;\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":52}],28:[function(require,module,exports){\n/**\n* Fable Settings Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nconst libPrecedent = require('precedent');\nconst libFableSettingsTemplateProcessor = require('./Fable-Settings-TemplateProcessor.js');\n\nclass FableSettings\n{\n\tconstructor(pFableSettings)\n\t{\n\t\t// Expose the dependencies for downstream re-use\n\t\tthis.dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libPrecedent\n\t\t\t});\n\n\t\t// Initialize the settings value template processor\n\t\tthis.settingsTemplateProcessor = new libFableSettingsTemplateProcessor(this.dependencies);\n\n\t\t// set straight away so anything that uses it respects the initial setting\n\t\tthis._configureEnvTemplating(pFableSettings);\n\n\t\tthis.default = this.buildDefaultSettings();\n\n\t\t// Construct a new settings object\n\t\tlet tmpSettings = this.merge(pFableSettings, this.buildDefaultSettings());\n\n\t\t// The base settings object (what they were on initialization, before other actors have altered them)\n\t\tthis.base = JSON.parse(JSON.stringify(tmpSettings));\n\n\t\tif (tmpSettings.DefaultConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a DEFAULT configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.DefaultConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tif (tmpSettings.ConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.ConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tthis.settings = tmpSettings;\n\t}\n\n\t// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.\n\tbuildDefaultSettings()\n\t{\n\t\treturn JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));\n\t}\n\n\t// Update the configuration for environment variable templating based on the current settings object\n\t_configureEnvTemplating(pSettings)\n\t{\n\t\t// default environment variable templating to on\n\t\tthis._PerformEnvTemplating = !pSettings || pSettings.NoEnvReplacement !== true;\n\t}\n\n\t// Resolve (recursive) any environment variables found in settings object.\n\t_resolveEnv(pSettings)\n\t{\n\t\tfor (const tmpKey in pSettings)\n\t\t{\n\t\t\tif (typeof(pSettings[tmpKey]) === 'object')\n\t\t\t{\n\t\t\t\tthis._resolveEnv(pSettings[tmpKey]);\n\t\t\t}\n\t\t\telse if (typeof(pSettings[tmpKey]) === 'string')\n\t\t\t{\n\t\t\t\tpSettings[tmpKey] = this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if a value is an object (but not an array).\n\t */\n\t_isObject(value)\n\t{\n\t\treturn typeof(value) === 'object' && !Array.isArray(value);\n\t}\n\n\t/**\n\t * Merge two plain objects. Keys that are objects in both will be merged property-wise.\n\t */\n\t_deepMergeObjects(toObject, fromObject)\n\t{\n\t\tif (!fromObject || !this._isObject(fromObject))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tObject.keys(fromObject).forEach((key) =>\n\t\t{\n\t\t\tconst fromValue = fromObject[key];\n\t\t\tif (this._isObject(fromValue))\n\t\t\t{\n\t\t\t\tconst toValue = toObject[key];\n\t\t\t\tif (toValue && this._isObject(toValue))\n\t\t\t\t{\n\t\t\t\t\t// both are objects, so do a recursive merge\n\t\t\t\t\tthis._deepMergeObjects(toValue, fromValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoObject[key] = fromValue;\n\t\t});\n\t\treturn toObject;\n\t}\n\n\t// Merge some new object into the existing settings.\n\tmerge(pSettingsFrom, pSettingsTo)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\t\t// Default to the settings object if none is passed in for the merge.\n\t\tlet tmpSettingsTo = (typeof(pSettingsTo) === 'object') ? pSettingsTo : this.settings;\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\t\ttmpSettingsTo = this._deepMergeObjects(tmpSettingsTo, tmpSettingsFromCopy);\n\n\t\tif (this._PerformEnvTemplating)\n\t\t{\n\t\t\tthis._resolveEnv(tmpSettingsTo);\n\t\t}\n\t\t// Update env tempating config, since we just updated the config object, and it may have changed\n\t\tthis._configureEnvTemplating(tmpSettingsTo);\n\n\t\treturn tmpSettingsTo;\n\t}\n\n\t// Fill in settings gaps without overwriting settings that are already there\n\tfill(pSettingsFrom)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\n\t\tthis.settings = this._deepMergeObjects(tmpSettingsFromCopy, this.settings);\n\n\t\treturn this.settings;\n\t}\n};\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableSettings(pSettings);\n}\n\nmodule.exports = {new:autoConstruct, FableSettings:FableSettings};\n},{\"./Fable-Settings-Default\":26,\"./Fable-Settings-TemplateProcessor.js\":27,\"precedent\":49}],29:[function(require,module,exports){\n/**\n* Random Byte Generator - Browser version\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nclass RandomBytes\n{\n\tconstructor()\n\t{\n\n\t\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n\t\t// implementation. Also, find the complete implementation of crypto on IE11.\n\t\tthis.getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      \t\t(typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\t}\n\n\t// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\tgenerateWhatWGBytes()\n\t{\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tthis.getRandomValues(tmpBuffer);\n\t\treturn tmpBuffer;\n\t}\n\n\t// Math.random()-based (RNG)\n\tgenerateRandomBytes()\n\t{\n\t\t// If all else fails, use Math.random().  It's fast, but is of unspecified\n\t\t// quality.\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tfor (let i = 0, tmpValue; i < 16; i++)\n\t\t{\n\t\t\tif ((i & 0x03) === 0)\n\t\t\t{\n\t\t\t\ttmpValue = Math.random() * 0x100000000;\n\t\t\t}\n\n\t\t\ttmpBuffer[i] = tmpValue >>> ((i & 0x03) << 3) & 0xff;\n\t\t}\n\n\t\treturn tmpBuffer;\n\t}\n\n\tgenerate()\n\t{\n\t\tif (this.getRandomValues)\n\t\t{\n\t\t\treturn this.generateWhatWGBytes();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateRandomBytes();\n\t\t}\n\t}\n}\n\nmodule.exports = RandomBytes;\n\n},{}],30:[function(require,module,exports){\n/**\n* Fable UUID Generator\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable UUID\n*/\n\n/**\n* Fable Solution UUID Generation Main Class\n*\n* @class FableUUID\n* @constructor\n*/\n\nvar libRandomByteGenerator = require('./Fable-UUID-Random.js')\n\nclass FableUUID\n{\n\tconstructor(pSettings)\n\t{\n\t\t// Determine if the module is in \"Random UUID Mode\" which means just use the random character function rather than the v4 random UUID spec.\n\t\t// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.\n\t\tthis._UUIDModeRandom = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDModeRandom')) ? (pSettings.UUIDModeRandom == true) : false;\n\t\t// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec\n\t\t// Length for \"Random UUID Mode\" is set -- if not set it to 8\n\t\tthis._UUIDLength = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDLength')) ? (pSettings.UUIDLength + 0) : 8;\n\t\t// Dictionary for \"Random UUID Mode\"\n\t\tthis._UUIDRandomDictionary = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDDictionary')) ? (pSettings.UUIDDictionary + 0) : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n\t\tthis.randomByteGenerator = new libRandomByteGenerator();\n\n\t\t// Lookup table for hex codes\n\t\tthis._HexLookup = [];\n\t\tfor (let i = 0; i < 256; ++i)\n\t\t{\n\t\t\tthis._HexLookup[i] = (i + 0x100).toString(16).substr(1);\n\t\t}\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tbytesToUUID(pBuffer)\n\t{\n\t\tlet i = 0;\n\t\t// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\t\treturn ([\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], \n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]]\n\t\t\t\t]).join('');\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgenerateUUIDv4()\n\t{\n\t\tlet tmpBuffer = new Array(16);\n\t\tvar tmpRandomBytes = this.randomByteGenerator.generate();\n\n\t\t// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t\ttmpRandomBytes[6] = (tmpRandomBytes[6] & 0x0f) | 0x40;\n\t\ttmpRandomBytes[8] = (tmpRandomBytes[8] & 0x3f) | 0x80;\n\n\t\treturn this.bytesToUUID(tmpRandomBytes);\n\t}\n\n\t// Simple random UUID generation\n\tgenerateRandom()\n\t{\n\t\tlet tmpUUID = '';\n\n\t\tfor (let i = 0; i < this._UUIDLength; i++)\n\t\t{\n\t\t\ttmpUUID += this._UUIDRandomDictionary.charAt(Math.floor(Math.random() * (this._UUIDRandomDictionary.length-1)));\n\t\t}\n\n\t\treturn tmpUUID;\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgetUUID()\n\t{\n\t\tif (this._UUIDModeRandom)\n\t\t{\n\t\t\treturn this.generateRandom();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateUUIDv4();\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableUUID(pSettings);\n}\n\n\nmodule.exports = {new:autoConstruct, FableUUID:FableUUID};\n\n},{\"./Fable-UUID-Random.js\":29}],31:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libFableSettings = require('fable-settings').FableSettings;\nconst libFableUUID = require('fable-uuid').FableUUID;\nconst libFableLog = require('fable-log').FableLog;\n\n\n/**\n* Fable Application Services Support Library\n*\n* @class Fable\n*/\nclass Fable\n{\n\tconstructor(pSettings)\n\t{\n\t\tlet tmpSettings = new libFableSettings(pSettings);\n\n\t\tthis.settingsManager = tmpSettings;\n\n\t\t// Instantiate the UUID generator\n\t\tthis.libUUID = new libFableUUID(this.settingsManager.settings);\n\n\t\tthis.log = new libFableLog(this.settingsManager.settings);\n\t\tthis.log.initialize();\n\t}\n\n\tget settings()\n\t{\n\t\treturn this.settingsManager.settings;\n\t}\n\n\tget fable()\n\t{\n\t\treturn this;\n\t}\n\n\tgetUUID()\n\t{\n\t\treturn this.libUUID.getUUID();\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new Fable(pSettings);\n}\n\nmodule.exports = Fable;\n\n},{\"fable-log\":25,\"fable-settings\":28,\"fable-uuid\":30}],32:[function(require,module,exports){\n'use strict'\n\nvar UTF8_ACCEPT = 12\nvar UTF8_REJECT = 0\nvar UTF8_DATA = [\n  // The first part of the table maps bytes to character to a transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,\n  10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\n  // The second part of the table maps a state to a new state when adding a\n  // transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96,\n  0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\n  // The third part maps the current transition to a mask that needs to apply\n  // to the byte.\n  0x7F, 0x3F, 0x3F, 0x3F, 0x00, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07\n]\n\nfunction decodeURIComponent (uri) {\n  var percentPosition = uri.indexOf('%')\n  if (percentPosition === -1) return uri\n\n  var length = uri.length\n  var decoded = ''\n  var last = 0\n  var codepoint = 0\n  var startOfOctets = percentPosition\n  var state = UTF8_ACCEPT\n\n  while (percentPosition > -1 && percentPosition < length) {\n    var high = hexCodeToInt(uri[percentPosition + 1], 4)\n    var low = hexCodeToInt(uri[percentPosition + 2], 0)\n    var byte = high | low\n    var type = UTF8_DATA[byte]\n    state = UTF8_DATA[256 + state + type]\n    codepoint = (codepoint << 6) | (byte & UTF8_DATA[364 + type])\n\n    if (state === UTF8_ACCEPT) {\n      decoded += uri.slice(last, startOfOctets)\n\n      decoded += (codepoint <= 0xFFFF)\n        ? String.fromCharCode(codepoint)\n        : String.fromCharCode(\n          (0xD7C0 + (codepoint >> 10)),\n          (0xDC00 + (codepoint & 0x3FF))\n        )\n\n      codepoint = 0\n      last = percentPosition + 3\n      percentPosition = startOfOctets = uri.indexOf('%', last)\n    } else if (state === UTF8_REJECT) {\n      return null\n    } else {\n      percentPosition += 3\n      if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue\n      return null\n    }\n  }\n\n  return decoded + uri.slice(last)\n}\n\nvar HEX = {\n  '0': 0,\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  '4': 4,\n  '5': 5,\n  '6': 6,\n  '7': 7,\n  '8': 8,\n  '9': 9,\n  'a': 10,\n  'A': 10,\n  'b': 11,\n  'B': 11,\n  'c': 12,\n  'C': 12,\n  'd': 13,\n  'D': 13,\n  'e': 14,\n  'E': 14,\n  'f': 15,\n  'F': 15\n}\n\nfunction hexCodeToInt (c, shift) {\n  var i = HEX[c]\n  return i === undefined ? 255 : i << shift\n}\n\nmodule.exports = decodeURIComponent\n\n},{}],33:[function(require,module,exports){\n'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\n},{}],34:[function(require,module,exports){\n\"use strict\";\n\nconst parse = require(\"./parse\");\nconst stringify = require(\"./stringify\");\n\nconst fastQuerystring = {\n  parse,\n  stringify,\n};\n\n/**\n * Enable TS and JS support\n *\n * - `const qs = require('fast-querystring')`\n * - `import qs from 'fast-querystring'`\n */\nmodule.exports = fastQuerystring;\nmodule.exports.default = fastQuerystring;\nmodule.exports.parse = parse;\nmodule.exports.stringify = stringify;\n\n},{\"./parse\":36,\"./stringify\":37}],35:[function(require,module,exports){\n// This file is taken from Node.js project.\n// Full implementation can be found from https://github.com/nodejs/node/blob/main/lib/internal/querystring.js\n\nconst hexTable = Array.from(\n  { length: 256 },\n  (_, i) => \"%\" + ((i < 16 ? \"0\" : \"\") + i.toString(16)).toUpperCase(),\n);\n\n// These characters do not need escaping when generating query strings:\n// ! - . _ ~\n// ' ( ) *\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\n// rome-ignore format: the array should not be formatted\nconst noEscape = new Int8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 80 - 95\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, // 112 - 127\n]);\n\n/**\n * @param {string} str\n * @returns {string}\n */\nfunction encodeString(str) {\n  const len = str.length;\n  if (len === 0) return \"\";\n\n  let out = \"\";\n  let lastPos = 0;\n  let i = 0;\n\n  outer: for (; i < len; i++) {\n    let c = str.charCodeAt(i);\n\n    // ASCII\n    while (c < 0x80) {\n      if (noEscape[c] !== 1) {\n        if (lastPos < i) out += str.slice(lastPos, i);\n        lastPos = i + 1;\n        out += hexTable[c];\n      }\n\n      if (++i === len) break outer;\n\n      c = str.charCodeAt(i);\n    }\n\n    if (lastPos < i) out += str.slice(lastPos, i);\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += hexTable[0xc0 | (c >> 6)] + hexTable[0x80 | (c & 0x3f)];\n      continue;\n    }\n    if (c < 0xd800 || c >= 0xe000) {\n      lastPos = i + 1;\n      out +=\n        hexTable[0xe0 | (c >> 12)] +\n        hexTable[0x80 | ((c >> 6) & 0x3f)] +\n        hexTable[0x80 | (c & 0x3f)];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n\n    // This branch should never happen because all URLSearchParams entries\n    // should already be converted to USVString. But, included for\n    // completion's sake anyway.\n    if (i >= len) {\n      throw new Error(\"URI malformed\");\n    }\n\n    const c2 = str.charCodeAt(i) & 0x3ff;\n\n    lastPos = i + 1;\n    c = 0x10000 + (((c & 0x3ff) << 10) | c2);\n    out +=\n      hexTable[0xf0 | (c >> 18)] +\n      hexTable[0x80 | ((c >> 12) & 0x3f)] +\n      hexTable[0x80 | ((c >> 6) & 0x3f)] +\n      hexTable[0x80 | (c & 0x3f)];\n  }\n  if (lastPos === 0) return str;\n  if (lastPos < len) return out + str.slice(lastPos);\n  return out;\n}\n\nmodule.exports = { encodeString };\n\n},{}],36:[function(require,module,exports){\n\"use strict\";\n\nconst fastDecode = require(\"fast-decode-uri-component\");\n\nconst plusRegex = /\\+/g;\nconst Empty = function () {};\nEmpty.prototype = Object.create(null);\n\n/**\n * @callback parse\n * @param {string} input\n */\nfunction parse(input) {\n  // Optimization: Use new Empty() instead of Object.create(null) for performance\n  // v8 has a better optimization for initializing functions compared to Object\n  const result = new Empty();\n\n  if (typeof input !== \"string\") {\n    return result;\n  }\n\n  let inputLength = input.length;\n  let key = \"\";\n  let value = \"\";\n  let startingIndex = -1;\n  let equalityIndex = -1;\n  let shouldDecodeKey = false;\n  let shouldDecodeValue = false;\n  let keyHasPlus = false;\n  let valueHasPlus = false;\n  let hasBothKeyValuePair = false;\n  let c = 0;\n\n  // Have a boundary of input.length + 1 to access last pair inside the loop.\n  for (let i = 0; i < inputLength + 1; i++) {\n    c = i !== inputLength ? input.charCodeAt(i) : 38;\n\n    // Handle '&' and end of line to pass the current values to result\n    if (c === 38) {\n      hasBothKeyValuePair = equalityIndex > startingIndex;\n\n      // Optimization: Reuse equality index to store the end of key\n      if (!hasBothKeyValuePair) {\n        equalityIndex = i;\n      }\n\n      key = input.slice(startingIndex + 1, equalityIndex);\n\n      // Add key/value pair only if the range size is greater than 1; a.k.a. contains at least \"=\"\n      if (hasBothKeyValuePair || key.length > 0) {\n        // Optimization: Replace '+' with space\n        if (keyHasPlus) {\n          key = key.replace(plusRegex, \" \");\n        }\n\n        // Optimization: Do not decode if it's not necessary.\n        if (shouldDecodeKey) {\n          key = fastDecode(key) || key;\n        }\n\n        if (hasBothKeyValuePair) {\n          value = input.slice(equalityIndex + 1, i);\n\n          if (valueHasPlus) {\n            value = value.replace(plusRegex, \" \");\n          }\n\n          if (shouldDecodeValue) {\n            value = fastDecode(value) || value;\n          }\n        }\n        const currentValue = result[key];\n\n        if (currentValue === undefined) {\n          result[key] = value;\n        } else {\n          // Optimization: value.pop is faster than Array.isArray(value)\n          if (currentValue.pop) {\n            currentValue.push(value);\n          } else {\n            result[key] = [currentValue, value];\n          }\n        }\n      }\n\n      // Reset reading key value pairs\n      value = \"\";\n      startingIndex = i;\n      equalityIndex = i;\n      shouldDecodeKey = false;\n      shouldDecodeValue = false;\n      keyHasPlus = false;\n      valueHasPlus = false;\n    }\n    // Check '='\n    else if (c === 61) {\n      if (equalityIndex <= startingIndex) {\n        equalityIndex = i;\n      }\n      // If '=' character occurs again, we should decode the input.\n      else {\n        shouldDecodeValue = true;\n      }\n    }\n    // Check '+', and remember to replace it with empty space.\n    else if (c === 43) {\n      if (equalityIndex > startingIndex) {\n        valueHasPlus = true;\n      } else {\n        keyHasPlus = true;\n      }\n    }\n    // Check '%' character for encoding\n    else if (c === 37) {\n      if (equalityIndex > startingIndex) {\n        shouldDecodeValue = true;\n      } else {\n        shouldDecodeKey = true;\n      }\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = parse;\n\n},{\"fast-decode-uri-component\":32}],37:[function(require,module,exports){\n\"use strict\";\n\nconst { encodeString } = require(\"./internals/querystring\");\n\nfunction getAsPrimitive(value) {\n  const type = typeof value;\n\n  if (type === \"string\") {\n    // Length check is handled inside encodeString function\n    return encodeString(value);\n  } else if (type === \"bigint\") {\n    return value.toString();\n  } else if (type === \"boolean\") {\n    return value ? \"true\" : \"false\";\n  } else if (type === \"number\" && Number.isFinite(value)) {\n    return value < 1e21 ? \"\" + value : encodeString(\"\" + value);\n  }\n\n  return \"\";\n}\n\n/**\n * @param {Record<string, string | number | boolean\n * | ReadonlyArray<string | number | boolean> | null>} input\n * @returns {string}\n */\nfunction stringify(input) {\n  let result = \"\";\n\n  if (input === null || typeof input !== \"object\") {\n    return result;\n  }\n\n  const separator = \"&\";\n  const keys = Object.keys(input);\n  const keyLength = keys.length;\n  let valueLength = 0;\n\n  for (let i = 0; i < keyLength; i++) {\n    const key = keys[i];\n    const value = input[key];\n    const encodedKey = encodeString(key) + \"=\";\n\n    if (i) {\n      result += separator;\n    }\n\n    if (Array.isArray(value)) {\n      valueLength = value.length;\n      for (let j = 0; j < valueLength; j++) {\n        if (j) {\n          result += separator;\n        }\n\n        // Optimization: Dividing into multiple lines improves the performance.\n        // Since v8 does not need to care about the '+' character if it was one-liner.\n        result += encodedKey;\n        result += getAsPrimitive(value[j]);\n      }\n    } else {\n      result += encodedKey;\n      result += getAsPrimitive(value);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = stringify;\n\n},{\"./internals/querystring\":35}],38:[function(require,module,exports){\n'use strict'\n\nconst HandlerStorage = require('./handler_storage')\n\nconst NODE_TYPES = {\n  STATIC: 0,\n  PARAMETRIC: 1,\n  WILDCARD: 2\n}\n\nclass Node {\n  constructor () {\n    this.handlerStorage = new HandlerStorage()\n  }\n}\n\nclass ParentNode extends Node {\n  constructor () {\n    super()\n    this.staticChildren = {}\n  }\n\n  findStaticMatchingChild (path, pathIndex) {\n    const staticChild = this.staticChildren[path.charAt(pathIndex)]\n    if (staticChild === undefined || !staticChild.matchPrefix(path, pathIndex)) {\n      return null\n    }\n    return staticChild\n  }\n\n  createStaticChild (path) {\n    if (path.length === 0) {\n      return this\n    }\n\n    let staticChild = this.staticChildren[path.charAt(0)]\n    if (staticChild) {\n      let i = 1\n      for (; i < staticChild.prefix.length; i++) {\n        if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {\n          staticChild = staticChild.split(this, i)\n          break\n        }\n      }\n      return staticChild.createStaticChild(path.slice(i))\n    }\n\n    const label = path.charAt(0)\n    this.staticChildren[label] = new StaticNode(path)\n    return this.staticChildren[label]\n  }\n}\n\nclass StaticNode extends ParentNode {\n  constructor (prefix) {\n    super()\n    this.prefix = prefix\n    this.wildcardChild = null\n    this.parametricChildren = []\n    this.kind = NODE_TYPES.STATIC\n    this._compilePrefixMatch()\n  }\n\n  createParametricChild (regex, staticSuffix) {\n    const regexpSource = regex && regex.source\n\n    let parametricChild = this.parametricChildren.find(child => {\n      const childRegexSource = child.regex && child.regex.source\n      return childRegexSource === regexpSource\n    })\n\n    if (parametricChild) {\n      return parametricChild\n    }\n\n    parametricChild = new ParametricNode(regex, staticSuffix)\n    this.parametricChildren.push(parametricChild)\n    this.parametricChildren.sort((child1, child2) => {\n      if (!child1.isRegex) return 1\n      if (!child2.isRegex) return -1\n\n      if (child1.staticSuffix === null) return 1\n      if (child2.staticSuffix === null) return -1\n\n      if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1\n      if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1\n\n      return 0\n    })\n\n    return parametricChild\n  }\n\n  createWildcardChild () {\n    if (this.wildcardChild) {\n      return this.wildcardChild\n    }\n\n    this.wildcardChild = new WildcardNode()\n    return this.wildcardChild\n  }\n\n  split (parentNode, length) {\n    const parentPrefix = this.prefix.slice(0, length)\n    const childPrefix = this.prefix.slice(length)\n\n    this.prefix = childPrefix\n    this._compilePrefixMatch()\n\n    const staticNode = new StaticNode(parentPrefix)\n    staticNode.staticChildren[childPrefix.charAt(0)] = this\n    parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode\n\n    return staticNode\n  }\n\n  getNextNode (path, pathIndex, nodeStack, paramsCount) {\n    let node = this.findStaticMatchingChild(path, pathIndex)\n    let parametricBrotherNodeIndex = 0\n\n    if (node === null) {\n      if (this.parametricChildren.length === 0) {\n        return this.wildcardChild\n      }\n\n      node = this.parametricChildren[0]\n      parametricBrotherNodeIndex = 1\n    }\n\n    if (this.wildcardChild !== null) {\n      nodeStack.push({\n        paramsCount,\n        brotherPathIndex: pathIndex,\n        brotherNode: this.wildcardChild\n      })\n    }\n\n    for (let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--) {\n      nodeStack.push({\n        paramsCount,\n        brotherPathIndex: pathIndex,\n        brotherNode: this.parametricChildren[i]\n      })\n    }\n\n    return node\n  }\n\n  _compilePrefixMatch () {\n    if (this.prefix.length === 1) {\n      this.matchPrefix = () => true\n      return\n    }\n\n    const lines = []\n    for (let i = 1; i < this.prefix.length; i++) {\n      const charCode = this.prefix.charCodeAt(i)\n      lines.push(`path.charCodeAt(i + ${i}) === ${charCode}`)\n    }\n    this.matchPrefix = new Function('path', 'i', `return ${lines.join(' && ')}`) // eslint-disable-line\n  }\n}\n\nclass ParametricNode extends ParentNode {\n  constructor (regex, staticSuffix) {\n    super()\n    this.isRegex = !!regex\n    this.regex = regex || null\n    this.staticSuffix = staticSuffix || null\n    this.kind = NODE_TYPES.PARAMETRIC\n  }\n\n  getNextNode (path, pathIndex) {\n    return this.findStaticMatchingChild(path, pathIndex)\n  }\n}\n\nclass WildcardNode extends Node {\n  constructor () {\n    super()\n    this.kind = NODE_TYPES.WILDCARD\n  }\n\n  getNextNode () {\n    return null\n  }\n}\n\nmodule.exports = { StaticNode, ParametricNode, WildcardNode, NODE_TYPES }\n\n},{\"./handler_storage\":39}],39:[function(require,module,exports){\n'use strict'\n\nclass HandlerStorage {\n  constructor () {\n    this.unconstrainedHandler = null // optimized reference to the handler that will match most of the time\n    this.constraints = []\n    this.handlers = [] // unoptimized list of handler objects for which the fast matcher function will be compiled\n    this.constrainedHandlerStores = null\n  }\n\n  // This is the hot path for node handler finding -- change with care!\n  getMatchingHandler (derivedConstraints) {\n    if (derivedConstraints === undefined) {\n      return this.unconstrainedHandler\n    }\n    return this._getHandlerMatchingConstraints(derivedConstraints)\n  }\n\n  addHandler (handler, params, store, constrainer, constraints) {\n    const handlerObject = {\n      handler,\n      params,\n      constraints,\n      store: store || null,\n      _createParamsObject: this._compileCreateParamsObject(params)\n    }\n\n    if (Object.keys(constraints).length === 0) {\n      this.unconstrainedHandler = handlerObject\n    }\n\n    for (const constraint of Object.keys(constraints)) {\n      if (!this.constraints.includes(constraint)) {\n        if (constraint === 'version') {\n          // always check the version constraint first as it is the most selective\n          this.constraints.unshift(constraint)\n        } else {\n          this.constraints.push(constraint)\n        }\n      }\n    }\n\n    if (this.handlers.length >= 32) {\n      throw new Error('find-my-way supports a maximum of 32 route handlers per node when there are constraints, limit reached')\n    }\n\n    this.handlers.push(handlerObject)\n    // Sort the most constrained handlers to the front of the list of handlers so they are tested first.\n    this.handlers.sort((a, b) => Object.keys(a.constraints).length - Object.keys(b.constraints).length)\n\n    this._compileGetHandlerMatchingConstraints(constrainer, constraints)\n  }\n\n  _compileCreateParamsObject (params) {\n    const lines = []\n    for (let i = 0; i < params.length; i++) {\n      lines.push(`'${params[i]}': paramsArray[${i}]`)\n    }\n    return new Function('paramsArray', `return {${lines.join(',')}}`)  // eslint-disable-line\n  }\n\n  _getHandlerMatchingConstraints () {\n    return null\n  }\n\n  // Builds a store object that maps from constraint values to a bitmap of handler indexes which pass the constraint for a value\n  // So for a host constraint, this might look like { \"fastify.io\": 0b0010, \"google.ca\": 0b0101 }, meaning the 3rd handler is constrainted to fastify.io, and the 2nd and 4th handlers are constrained to google.ca.\n  // The store's implementation comes from the strategies provided to the Router.\n  _buildConstraintStore (store, constraint) {\n    for (let i = 0; i < this.handlers.length; i++) {\n      const handler = this.handlers[i]\n      const constraintValue = handler.constraints[constraint]\n      if (constraintValue !== undefined) {\n        let indexes = store.get(constraintValue) || 0\n        indexes |= 1 << i // set the i-th bit for the mask because this handler is constrained by this value https://stackoverflow.com/questions/1436438/how-do-you-set-clear-and-toggle-a-single-bit-in-javascrip\n        store.set(constraintValue, indexes)\n      }\n    }\n  }\n\n  // Builds a bitmask for a given constraint that has a bit for each handler index that is 0 when that handler *is* constrained and 1 when the handler *isnt* constrainted. This is opposite to what might be obvious, but is just for convienience when doing the bitwise operations.\n  _constrainedIndexBitmask (constraint) {\n    let mask = 0\n    for (let i = 0; i < this.handlers.length; i++) {\n      const handler = this.handlers[i]\n      const constraintValue = handler.constraints[constraint]\n      if (constraintValue !== undefined) {\n        mask |= 1 << i\n      }\n    }\n    return ~mask\n  }\n\n  // Compile a fast function to match the handlers for this node\n  // The function implements a general case multi-constraint matching algorithm.\n  // The general idea is this: we have a bunch of handlers, each with a potentially different set of constraints, and sometimes none at all. We're given a list of constraint values and we have to use the constraint-value-comparison strategies to see which handlers match the constraint values passed in.\n  // We do this by asking each constraint store which handler indexes match the given constraint value for each store. Trickily, the handlers that a store says match are the handlers constrained by that store, but handlers that aren't constrained at all by that store could still match just fine. So, each constraint store can only describe matches for it, and it won't have any bearing on the handlers it doesn't care about. For this reason, we have to ask each stores which handlers match and track which have been matched (or not cared about) by all of them.\n  // We use bitmaps to represent these lists of matches so we can use bitwise operations to implement this efficiently. Bitmaps are cheap to allocate, let us implement this masking behaviour in one CPU instruction, and are quite compact in memory. We start with a bitmap set to all 1s representing every handler that is a match candidate, and then for each constraint, see which handlers match using the store, and then mask the result by the mask of handlers that that store applies to, and bitwise AND with the candidate list. Phew.\n  // We consider all this compiling function complexity to be worth it, because the naive implementation that just loops over the handlers asking which stores match is quite a bit slower.\n  _compileGetHandlerMatchingConstraints (constrainer) {\n    this.constrainedHandlerStores = {}\n\n    for (const constraint of this.constraints) {\n      const store = constrainer.newStoreForConstraint(constraint)\n      this.constrainedHandlerStores[constraint] = store\n\n      this._buildConstraintStore(store, constraint)\n    }\n\n    const lines = []\n    lines.push(`\n    let candidates = ${(1 << this.handlers.length) - 1}\n    let mask, matches\n    `)\n    for (const constraint of this.constraints) {\n      // Setup the mask for indexes this constraint applies to. The mask bits are set to 1 for each position if the constraint applies.\n      lines.push(`\n      mask = ${this._constrainedIndexBitmask(constraint)}\n      value = derivedConstraints.${constraint}\n      `)\n\n      // If there's no constraint value, none of the handlers constrained by this constraint can match. Remove them from the candidates.\n      // If there is a constraint value, get the matching indexes bitmap from the store, and mask it down to only the indexes this constraint applies to, and then bitwise and with the candidates list to leave only matching candidates left.\n      const strategy = constrainer.strategies[constraint]\n      const matchMask = strategy.mustMatchWhenDerived ? 'matches' : '(matches | mask)'\n\n      lines.push(`\n      if (value === undefined) {\n        candidates &= mask\n      } else {\n        matches = this.constrainedHandlerStores.${constraint}.get(value) || 0\n        candidates &= ${matchMask}\n      }\n      if (candidates === 0) return null;\n      `)\n    }\n\n    // There are some constraints that can be derived and marked as \"must match\", where if they are derived, they only match routes that actually have a constraint on the value, like the SemVer version constraint.\n    // An example: a request comes in for version 1.x, and this node has a handler that matches the path, but there's no version constraint. For SemVer, the find-my-way semantics do not match this handler to that request.\n    // This function is used by Nodes with handlers to match when they don't have any constrained routes to exclude request that do have must match derived constraints present.\n    for (const constraint in constrainer.strategies) {\n      const strategy = constrainer.strategies[constraint]\n      if (strategy.mustMatchWhenDerived && !this.constraints.includes(constraint)) {\n        lines.push(`if (derivedConstraints.${constraint} !== undefined) return null`)\n      }\n    }\n\n    // Return the first handler who's bit is set in the candidates https://stackoverflow.com/questions/18134985/how-to-find-index-of-first-set-bit\n    lines.push('return this.handlers[Math.floor(Math.log2(candidates))]')\n\n    this._getHandlerMatchingConstraints = new Function('derivedConstraints', lines.join('\\n')) // eslint-disable-line\n  }\n}\n\nmodule.exports = HandlerStorage\n\n},{}],40:[function(require,module,exports){\n'use strict'\n\n/*\n  Char codes:\n    '!': 33 - !\n    '#': 35 - %23\n    '$': 36 - %24\n    '%': 37 - %25\n    '&': 38 - %26\n    ''': 39 - '\n    '(': 40 - (\n    ')': 41 - )\n    '*': 42 - *\n    '+': 43 - %2B\n    ',': 44 - %2C\n    '-': 45 - -\n    '.': 46 - .\n    '/': 47 - %2F\n    ':': 58 - %3A\n    ';': 59 - %3B\n    '=': 61 - %3D\n    '?': 63 - %3F\n    '@': 64 - %40\n    '_': 95 - _\n    '~': 126 - ~\n*/\n\nconst assert = require('assert')\nconst querystring = require('fast-querystring')\nconst isRegexSafe = require('safe-regex2')\nconst deepEqual = require('fast-deep-equal')\nconst { flattenNode, compressFlattenedNode, prettyPrintFlattenedNode, prettyPrintRoutesArray } = require('./lib/pretty-print')\nconst { StaticNode, NODE_TYPES } = require('./custom_node')\nconst Constrainer = require('./lib/constrainer')\nconst httpMethods = require('./lib/http-methods')\nconst { safeDecodeURI, safeDecodeURIComponent } = require('./lib/url-sanitizer')\n\nconst FULL_PATH_REGEXP = /^https?:\\/\\/.*?\\//\nconst OPTIONAL_PARAM_REGEXP = /(\\/:[^/()]*?)\\?(\\/?)/\n\nif (!isRegexSafe(FULL_PATH_REGEXP)) {\n  throw new Error('the FULL_PATH_REGEXP is not safe, update this module')\n}\n\nif (!isRegexSafe(OPTIONAL_PARAM_REGEXP)) {\n  throw new Error('the OPTIONAL_PARAM_REGEXP is not safe, update this module')\n}\n\nfunction Router (opts) {\n  if (!(this instanceof Router)) {\n    return new Router(opts)\n  }\n  opts = opts || {}\n\n  if (opts.defaultRoute) {\n    assert(typeof opts.defaultRoute === 'function', 'The default route must be a function')\n    this.defaultRoute = opts.defaultRoute\n  } else {\n    this.defaultRoute = null\n  }\n\n  if (opts.onBadUrl) {\n    assert(typeof opts.onBadUrl === 'function', 'The bad url handler must be a function')\n    this.onBadUrl = opts.onBadUrl\n  } else {\n    this.onBadUrl = null\n  }\n\n  if (opts.buildPrettyMeta) {\n    assert(typeof opts.buildPrettyMeta === 'function', 'buildPrettyMeta must be a function')\n    this.buildPrettyMeta = opts.buildPrettyMeta\n  } else {\n    this.buildPrettyMeta = defaultBuildPrettyMeta\n  }\n\n  if (opts.querystringParser) {\n    assert(typeof opts.querystringParser === 'function', 'querystringParser must be a function')\n    this.querystringParser = opts.querystringParser\n  } else {\n    this.querystringParser = (query) => query === '' ? {} : querystring.parse(query)\n  }\n\n  this.caseSensitive = opts.caseSensitive === undefined ? true : opts.caseSensitive\n  this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false\n  this.ignoreDuplicateSlashes = opts.ignoreDuplicateSlashes || false\n  this.maxParamLength = opts.maxParamLength || 100\n  this.allowUnsafeRegex = opts.allowUnsafeRegex || false\n  this.routes = []\n  this.trees = {}\n  this.constrainer = new Constrainer(opts.constraints)\n\n  this._routesPatterns = {}\n}\n\nRouter.prototype.on = function on (method, path, opts, handler, store) {\n  if (typeof opts === 'function') {\n    if (handler !== undefined) {\n      store = handler\n    }\n    handler = opts\n    opts = {}\n  }\n  // path validation\n  assert(typeof path === 'string', 'Path should be a string')\n  assert(path.length > 0, 'The path could not be empty')\n  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`')\n  // handler validation\n  assert(typeof handler === 'function', 'Handler should be a function')\n\n  // path ends with optional parameter\n  const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP)\n  if (optionalParamMatch) {\n    assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, 'Optional Parameter needs to be the last parameter of the path')\n\n    const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, '$1$2')\n    const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, '$2')\n\n    this.on(method, pathFull, opts, handler, store)\n    this.on(method, pathOptional, opts, handler, store)\n    return\n  }\n\n  const route = path\n\n  if (this.ignoreDuplicateSlashes) {\n    path = removeDuplicateSlashes(path)\n  }\n\n  if (this.ignoreTrailingSlash) {\n    path = trimLastSlash(path)\n  }\n\n  const methods = Array.isArray(method) ? method : [method]\n  for (const method of methods) {\n    this._on(method, path, opts, handler, store, route)\n    this.routes.push({ method, path, opts, handler, store })\n  }\n}\n\nRouter.prototype._on = function _on (method, path, opts, handler, store) {\n  assert(typeof method === 'string', 'Method should be a string')\n  assert(httpMethods.includes(method), `Method '${method}' is not an http method.`)\n\n  let constraints = {}\n  if (opts.constraints !== undefined) {\n    assert(typeof opts.constraints === 'object' && opts.constraints !== null, 'Constraints should be an object')\n    if (Object.keys(opts.constraints).length !== 0) {\n      constraints = opts.constraints\n    }\n  }\n\n  this.constrainer.validateConstraints(constraints)\n  // Let the constrainer know if any constraints are being used now\n  this.constrainer.noteUsage(constraints)\n\n  // Boot the tree for this method if it doesn't exist yet\n  if (this.trees[method] === undefined) {\n    this.trees[method] = new StaticNode('/')\n    this._routesPatterns[method] = []\n  }\n\n  if (path === '*' && this.trees[method].prefix.length !== 0) {\n    const currentRoot = this.trees[method]\n    this.trees[method] = new StaticNode('')\n    this.trees[method].staticChildren['/'] = currentRoot\n  }\n\n  let currentNode = this.trees[method]\n  let parentNodePathIndex = currentNode.prefix.length\n\n  const params = []\n  for (let i = 0; i <= path.length; i++) {\n    if (path.charCodeAt(i) === 58 && path.charCodeAt(i + 1) === 58) {\n      // It's a double colon\n      i++\n      continue\n    }\n\n    const isParametricNode = path.charCodeAt(i) === 58 && path.charCodeAt(i + 1) !== 58\n    const isWildcardNode = path.charCodeAt(i) === 42\n\n    if (isParametricNode || isWildcardNode || (i === path.length && i !== parentNodePathIndex)) {\n      let staticNodePath = path.slice(parentNodePathIndex, i)\n      if (!this.caseSensitive) {\n        staticNodePath = staticNodePath.toLowerCase()\n      }\n      staticNodePath = staticNodePath.split('::').join(':')\n      staticNodePath = staticNodePath.split('%').join('%25')\n      // add the static part of the route to the tree\n      currentNode = currentNode.createStaticChild(staticNodePath)\n    }\n\n    if (isParametricNode) {\n      let isRegexNode = false\n      const regexps = []\n\n      let lastParamStartIndex = i + 1\n      for (let j = lastParamStartIndex; ; j++) {\n        const charCode = path.charCodeAt(j)\n\n        const isRegexParam = charCode === 40\n        const isStaticPart = charCode === 45 || charCode === 46\n        const isEndOfNode = charCode === 47 || j === path.length\n\n        if (isRegexParam || isStaticPart || isEndOfNode) {\n          const paramName = path.slice(lastParamStartIndex, j)\n          params.push(paramName)\n\n          isRegexNode = isRegexNode || isRegexParam || isStaticPart\n\n          if (isRegexParam) {\n            const endOfRegexIndex = getClosingParenthensePosition(path, j)\n            const regexString = path.slice(j, endOfRegexIndex + 1)\n\n            if (!this.allowUnsafeRegex) {\n              assert(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`)\n            }\n\n            regexps.push(trimRegExpStartAndEnd(regexString))\n\n            j = endOfRegexIndex + 1\n          } else {\n            regexps.push('(.*?)')\n          }\n\n          const staticPartStartIndex = j\n          for (; j < path.length; j++) {\n            const charCode = path.charCodeAt(j)\n            if (charCode === 47) break\n            if (charCode === 58) {\n              const nextCharCode = path.charCodeAt(j + 1)\n              if (nextCharCode === 58) j++\n              else break\n            }\n          }\n\n          let staticPart = path.slice(staticPartStartIndex, j)\n          if (staticPart) {\n            staticPart = staticPart.split('::').join(':')\n            staticPart = staticPart.split('%').join('%25')\n            regexps.push(escapeRegExp(staticPart))\n          }\n\n          lastParamStartIndex = j + 1\n\n          if (isEndOfNode || path.charCodeAt(j) === 47 || j === path.length) {\n            const nodePattern = isRegexNode ? '()' + staticPart : staticPart\n\n            path = path.slice(0, i + 1) + nodePattern + path.slice(j)\n            i += nodePattern.length\n\n            const regex = isRegexNode ? new RegExp('^' + regexps.join('') + '$') : null\n            currentNode = currentNode.createParametricChild(regex, staticPart || null)\n            parentNodePathIndex = i + 1\n            break\n          }\n        }\n      }\n    } else if (isWildcardNode) {\n      // add the wildcard parameter\n      params.push('*')\n      currentNode = currentNode.createWildcardChild()\n      parentNodePathIndex = i + 1\n\n      if (i !== path.length - 1) {\n        throw new Error('Wildcard must be the last character in the route')\n      }\n    }\n  }\n\n  if (!this.caseSensitive) {\n    path = path.toLowerCase()\n  }\n\n  if (path === '*') {\n    path = '/*'\n  }\n\n  for (const existRoute of this._routesPatterns[method]) {\n    if (existRoute.path === path && deepEqual(existRoute.constraints, constraints)) {\n      throw new Error(`Method '${method}' already declared for route '${path}' with constraints '${JSON.stringify(constraints)}'`)\n    }\n  }\n  this._routesPatterns[method].push({ path, params, constraints })\n\n  currentNode.handlerStorage.addHandler(handler, params, store, this.constrainer, constraints)\n}\n\nRouter.prototype.hasConstraintStrategy = function (strategyName) {\n  return this.constrainer.hasConstraintStrategy(strategyName)\n}\n\nRouter.prototype.addConstraintStrategy = function (constraints) {\n  this.constrainer.addConstraintStrategy(constraints)\n  this._rebuild(this.routes)\n}\n\nRouter.prototype.reset = function reset () {\n  this.trees = {}\n  this.routes = []\n  this._routesPatterns = {}\n}\n\nRouter.prototype.off = function off (method, path, constraints) {\n  // path validation\n  assert(typeof path === 'string', 'Path should be a string')\n  assert(path.length > 0, 'The path could not be empty')\n  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`')\n  // options validation\n  assert(\n    typeof constraints === 'undefined' ||\n    (typeof constraints === 'object' && !Array.isArray(constraints) && constraints !== null),\n    'Constraints should be an object or undefined.')\n\n  // path ends with optional parameter\n  const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP)\n  if (optionalParamMatch) {\n    assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, 'Optional Parameter needs to be the last parameter of the path')\n\n    const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, '$1$2')\n    const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, '$2')\n\n    this.off(method, pathFull, constraints)\n    this.off(method, pathOptional, constraints)\n    return\n  }\n\n  if (this.ignoreDuplicateSlashes) {\n    path = removeDuplicateSlashes(path)\n  }\n\n  if (this.ignoreTrailingSlash) {\n    path = trimLastSlash(path)\n  }\n\n  const methods = Array.isArray(method) ? method : [method]\n  for (const method of methods) {\n    this._off(method, path, constraints)\n  }\n}\n\nRouter.prototype._off = function _off (method, path, constraints) {\n  // method validation\n  assert(typeof method === 'string', 'Method should be a string')\n  assert(httpMethods.includes(method), `Method '${method}' is not an http method.`)\n\n  function matcherWithoutConstraints (route) {\n    return method !== route.method || path !== route.path\n  }\n\n  function matcherWithConstraints (route) {\n    return matcherWithoutConstraints(route) || !deepEqual(constraints, route.opts.constraints || {})\n  }\n\n  const predicate = constraints ? matcherWithConstraints : matcherWithoutConstraints\n\n  // Rebuild tree without the specific route\n  const newRoutes = this.routes.filter(predicate)\n  this._rebuild(newRoutes)\n}\n\nRouter.prototype.lookup = function lookup (req, res, ctx, done) {\n  if (typeof ctx === 'function') {\n    done = ctx\n    ctx = undefined\n  }\n\n  if (done === undefined) {\n    const constraints = this.constrainer.deriveConstraints(req, ctx)\n    const handle = this.find(req.method, req.url, constraints)\n    return this.callHandler(handle, req, res, ctx)\n  }\n\n  this.constrainer.deriveConstraints(req, ctx, (err, constraints) => {\n    if (err !== null) {\n      done(err)\n      return\n    }\n\n    try {\n      const handle = this.find(req.method, req.url, constraints)\n      const result = this.callHandler(handle, req, res, ctx)\n      done(null, result)\n    } catch (err) {\n      done(err)\n    }\n  })\n}\n\nRouter.prototype.callHandler = function callHandler (handle, req, res, ctx) {\n  if (handle === null) return this._defaultRoute(req, res, ctx)\n  return ctx === undefined\n    ? handle.handler(req, res, handle.params, handle.store, handle.searchParams)\n    : handle.handler.call(ctx, req, res, handle.params, handle.store, handle.searchParams)\n}\n\nRouter.prototype.find = function find (method, path, derivedConstraints) {\n  let currentNode = this.trees[method]\n  if (currentNode === undefined) return null\n\n  if (path.charCodeAt(0) !== 47) { // 47 is '/'\n    path = path.replace(FULL_PATH_REGEXP, '/')\n  }\n\n  // This must be run before sanitizeUrl as the resulting function\n  // .sliceParameter must be constructed with same URL string used\n  // throughout the rest of this function.\n  if (this.ignoreDuplicateSlashes) {\n    path = removeDuplicateSlashes(path)\n  }\n\n  let sanitizedUrl\n  let querystring\n  let shouldDecodeParam\n\n  try {\n    sanitizedUrl = safeDecodeURI(path)\n    path = sanitizedUrl.path\n    querystring = sanitizedUrl.querystring\n    shouldDecodeParam = sanitizedUrl.shouldDecodeParam\n  } catch (error) {\n    return this._onBadUrl(path)\n  }\n\n  if (this.ignoreTrailingSlash) {\n    path = trimLastSlash(path)\n  }\n\n  const originPath = path\n\n  if (this.caseSensitive === false) {\n    path = path.toLowerCase()\n  }\n\n  const maxParamLength = this.maxParamLength\n\n  let pathIndex = currentNode.prefix.length\n  const params = []\n  const pathLen = path.length\n\n  const brothersNodesStack = []\n\n  while (true) {\n    if (pathIndex === pathLen) {\n      const handle = currentNode.handlerStorage.getMatchingHandler(derivedConstraints)\n\n      if (handle !== null) {\n        return {\n          handler: handle.handler,\n          store: handle.store,\n          params: handle._createParamsObject(params),\n          searchParams: this.querystringParser(querystring)\n        }\n      }\n    }\n\n    let node = currentNode.getNextNode(path, pathIndex, brothersNodesStack, params.length)\n\n    if (node === null) {\n      if (brothersNodesStack.length === 0) {\n        return null\n      }\n\n      const brotherNodeState = brothersNodesStack.pop()\n      pathIndex = brotherNodeState.brotherPathIndex\n      params.splice(brotherNodeState.paramsCount)\n      node = brotherNodeState.brotherNode\n    }\n\n    currentNode = node\n\n    // static route\n    if (currentNode.kind === NODE_TYPES.STATIC) {\n      pathIndex += currentNode.prefix.length\n      continue\n    }\n\n    if (currentNode.kind === NODE_TYPES.WILDCARD) {\n      let param = originPath.slice(pathIndex)\n      if (shouldDecodeParam) {\n        param = safeDecodeURIComponent(param)\n      }\n\n      params.push(param)\n      pathIndex = pathLen\n      continue\n    }\n\n    if (currentNode.kind === NODE_TYPES.PARAMETRIC) {\n      let paramEndIndex = originPath.indexOf('/', pathIndex)\n      if (paramEndIndex === -1) {\n        paramEndIndex = pathLen\n      }\n\n      let param = originPath.slice(pathIndex, paramEndIndex)\n      if (shouldDecodeParam) {\n        param = safeDecodeURIComponent(param)\n      }\n\n      if (currentNode.isRegex) {\n        const matchedParameters = currentNode.regex.exec(param)\n        if (matchedParameters === null) continue\n\n        for (let i = 1; i < matchedParameters.length; i++) {\n          const matchedParam = matchedParameters[i]\n          if (matchedParam.length > maxParamLength) {\n            return null\n          }\n          params.push(matchedParam)\n        }\n      } else {\n        if (param.length > maxParamLength) {\n          return null\n        }\n        params.push(param)\n      }\n\n      pathIndex = paramEndIndex\n    }\n  }\n}\n\nRouter.prototype._rebuild = function (routes) {\n  this.reset()\n\n  for (const route of routes) {\n    const { method, path, opts, handler, store } = route\n    this._on(method, path, opts, handler, store)\n    this.routes.push({ method, path, opts, handler, store })\n  }\n}\n\nRouter.prototype._defaultRoute = function (req, res, ctx) {\n  if (this.defaultRoute !== null) {\n    return ctx === undefined\n      ? this.defaultRoute(req, res)\n      : this.defaultRoute.call(ctx, req, res)\n  } else {\n    res.statusCode = 404\n    res.end()\n  }\n}\n\nRouter.prototype._onBadUrl = function (path) {\n  if (this.onBadUrl === null) {\n    return null\n  }\n  const onBadUrl = this.onBadUrl\n  return {\n    handler: (req, res, ctx) => onBadUrl(path, req, res),\n    params: {},\n    store: null\n  }\n}\n\nRouter.prototype.prettyPrint = function (opts = {}) {\n  opts.commonPrefix = opts.commonPrefix === undefined ? true : opts.commonPrefix // default to original behaviour\n  if (!opts.commonPrefix) return prettyPrintRoutesArray.call(this, this.routes, opts)\n  const root = {\n    prefix: '/',\n    nodes: [],\n    children: {}\n  }\n\n  for (const method in this.trees) {\n    const node = this.trees[method]\n    if (node) {\n      flattenNode(root, node, method)\n    }\n  }\n\n  compressFlattenedNode(root)\n\n  return prettyPrintFlattenedNode.call(this, root, '', true, opts)\n}\n\nfor (var i in httpMethods) {\n  /* eslint no-prototype-builtins: \"off\" */\n  if (!httpMethods.hasOwnProperty(i)) continue\n  const m = httpMethods[i]\n  const methodName = m.toLowerCase()\n\n  if (Router.prototype[methodName]) throw new Error('Method already exists: ' + methodName)\n\n  Router.prototype[methodName] = function (path, handler, store) {\n    return this.on(m, path, handler, store)\n  }\n}\n\nRouter.prototype.all = function (path, handler, store) {\n  this.on(httpMethods, path, handler, store)\n}\n\nmodule.exports = Router\n\nfunction escapeRegExp (string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction removeDuplicateSlashes (path) {\n  return path.replace(/\\/\\/+/g, '/')\n}\n\nfunction trimLastSlash (path) {\n  if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {\n    return path.slice(0, -1)\n  }\n  return path\n}\n\nfunction trimRegExpStartAndEnd (regexString) {\n  // removes chars that marks start \"^\" and end \"$\" of regexp\n  if (regexString.charCodeAt(1) === 94) {\n    regexString = regexString.slice(0, 1) + regexString.slice(2)\n  }\n\n  if (regexString.charCodeAt(regexString.length - 2) === 36) {\n    regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1)\n  }\n\n  return regexString\n}\n\nfunction getClosingParenthensePosition (path, idx) {\n  // `path.indexOf()` will always return the first position of the closing parenthese,\n  // but it's inefficient for grouped or wrong regexp expressions.\n  // see issues #62 and #63 for more info\n\n  var parentheses = 1\n\n  while (idx < path.length) {\n    idx++\n\n    // ignore skipped chars\n    if (path[idx] === '\\\\') {\n      idx++\n      continue\n    }\n\n    if (path[idx] === ')') {\n      parentheses--\n    } else if (path[idx] === '(') {\n      parentheses++\n    }\n\n    if (!parentheses) return idx\n  }\n\n  throw new TypeError('Invalid regexp expression in \"' + path + '\"')\n}\n\nfunction defaultBuildPrettyMeta (route) {\n  // buildPrettyMeta function must return an object, which will be parsed into key/value pairs for display\n  if (!route) return {}\n  if (!route.store) return {}\n  return Object.assign({}, route.store)\n}\n\n},{\"./custom_node\":38,\"./lib/constrainer\":41,\"./lib/http-methods\":42,\"./lib/pretty-print\":43,\"./lib/url-sanitizer\":46,\"assert\":1,\"fast-deep-equal\":33,\"fast-querystring\":34,\"safe-regex2\":53}],41:[function(require,module,exports){\n'use strict'\n\nconst acceptVersionStrategy = require('./strategies/accept-version')\nconst acceptHostStrategy = require('./strategies/accept-host')\nconst assert = require('assert')\n\nclass Constrainer {\n  constructor (customStrategies) {\n    this.strategies = {\n      version: acceptVersionStrategy,\n      host: acceptHostStrategy\n    }\n\n    this.strategiesInUse = new Set()\n    this.asyncStrategiesInUse = new Set()\n\n    // validate and optimize prototypes of given custom strategies\n    if (customStrategies) {\n      for (const strategy of Object.values(customStrategies)) {\n        this.addConstraintStrategy(strategy)\n      }\n    }\n  }\n\n  isStrategyUsed (strategyName) {\n    return this.strategiesInUse.has(strategyName) ||\n      this.asyncStrategiesInUse.has(strategyName)\n  }\n\n  hasConstraintStrategy (strategyName) {\n    const customConstraintStrategy = this.strategies[strategyName]\n    if (customConstraintStrategy !== undefined) {\n      return customConstraintStrategy.isCustom ||\n        this.isStrategyUsed(strategyName)\n    }\n    return false\n  }\n\n  addConstraintStrategy (strategy) {\n    assert(typeof strategy.name === 'string' && strategy.name !== '', 'strategy.name is required.')\n    assert(strategy.storage && typeof strategy.storage === 'function', 'strategy.storage function is required.')\n    assert(strategy.deriveConstraint && typeof strategy.deriveConstraint === 'function', 'strategy.deriveConstraint function is required.')\n\n    if (this.strategies[strategy.name] && this.strategies[strategy.name].isCustom) {\n      throw new Error(`There already exists a custom constraint with the name ${strategy.name}.`)\n    }\n\n    if (this.isStrategyUsed(strategy.name)) {\n      throw new Error(`There already exists a route with ${strategy.name} constraint.`)\n    }\n\n    strategy.isCustom = true\n    strategy.isAsync = strategy.deriveConstraint.length === 3\n    this.strategies[strategy.name] = strategy\n\n    if (strategy.mustMatchWhenDerived) {\n      this.noteUsage({ [strategy.name]: strategy })\n    }\n  }\n\n  deriveConstraints (req, ctx, done) {\n    const constraints = this.deriveSyncConstraints(req, ctx)\n\n    if (done === undefined) {\n      return constraints\n    }\n\n    this.deriveAsyncConstraints(constraints, req, ctx, done)\n  }\n\n  deriveSyncConstraints (req, ctx) {\n    return undefined\n  }\n\n  // When new constraints start getting used, we need to rebuild the deriver to derive them. Do so if we see novel constraints used.\n  noteUsage (constraints) {\n    if (constraints) {\n      const beforeSize = this.strategiesInUse.size\n      for (const key in constraints) {\n        const strategy = this.strategies[key]\n        if (strategy.isAsync) {\n          this.asyncStrategiesInUse.add(key)\n        } else {\n          this.strategiesInUse.add(key)\n        }\n      }\n      if (beforeSize !== this.strategiesInUse.size) {\n        this._buildDeriveConstraints()\n      }\n    }\n  }\n\n  newStoreForConstraint (constraint) {\n    if (!this.strategies[constraint]) {\n      throw new Error(`No strategy registered for constraint key ${constraint}`)\n    }\n    return this.strategies[constraint].storage()\n  }\n\n  validateConstraints (constraints) {\n    for (const key in constraints) {\n      const value = constraints[key]\n      if (typeof value === 'undefined') {\n        throw new Error('Can\\'t pass an undefined constraint value, must pass null or no key at all')\n      }\n      const strategy = this.strategies[key]\n      if (!strategy) {\n        throw new Error(`No strategy registered for constraint key ${key}`)\n      }\n      if (strategy.validate) {\n        strategy.validate(value)\n      }\n    }\n  }\n\n  deriveAsyncConstraints (constraints, req, ctx, done) {\n    let asyncConstraintsCount = this.asyncStrategiesInUse.size\n\n    if (asyncConstraintsCount === 0) {\n      done(null, constraints)\n      return\n    }\n\n    constraints = constraints || {}\n    for (const key of this.asyncStrategiesInUse) {\n      const strategy = this.strategies[key]\n      strategy.deriveConstraint(req, ctx, (err, constraintValue) => {\n        if (err !== null) {\n          done(err)\n          return\n        }\n\n        constraints[key] = constraintValue\n\n        if (--asyncConstraintsCount === 0) {\n          done(null, constraints)\n        }\n      })\n    }\n  }\n\n  // Optimization: build a fast function for deriving the constraints for all the strategies at once. We inline the definitions of the version constraint and the host constraint for performance.\n  // If no constraining strategies are in use (no routes constrain on host, or version, or any custom strategies) then we don't need to derive constraints for each route match, so don't do anything special, and just return undefined\n  // This allows us to not allocate an object to hold constraint values if no constraints are defined.\n  _buildDeriveConstraints () {\n    if (this.strategiesInUse.size === 0) return\n\n    const lines = ['return {']\n\n    for (const key of this.strategiesInUse) {\n      const strategy = this.strategies[key]\n      // Optimization: inline the derivation for the common built in constraints\n      if (!strategy.isCustom) {\n        if (key === 'version') {\n          lines.push('   version: req.headers[\\'accept-version\\'],')\n        } else if (key === 'host') {\n          lines.push('   host: req.headers.host || req.headers[\\':authority\\'],')\n        } else {\n          throw new Error('unknown non-custom strategy for compiling constraint derivation function')\n        }\n      } else {\n        lines.push(`  ${strategy.name}: this.strategies.${key}.deriveConstraint(req, ctx),`)\n      }\n    }\n\n    lines.push('}')\n\n    this.deriveSyncConstraints = new Function('req', 'ctx', lines.join('\\n')).bind(this) // eslint-disable-line\n  }\n}\n\nmodule.exports = Constrainer\n\n},{\"./strategies/accept-host\":44,\"./strategies/accept-version\":45,\"assert\":1}],42:[function(require,module,exports){\n'use strict'\n\n// defined by Node.js http module, a snapshot from Node.js 18.12.0\nconst httpMethods = [\n  'ACL', 'BIND', 'CHECKOUT', 'CONNECT', 'COPY', 'DELETE',\n  'GET', 'HEAD', 'LINK', 'LOCK', 'M-SEARCH', 'MERGE',\n  'MKACTIVITY', 'MKCALENDAR', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS',\n  'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT',\n  'REBIND', 'REPORT', 'SEARCH', 'SOURCE', 'SUBSCRIBE', 'TRACE',\n  'UNBIND', 'UNLINK', 'UNLOCK', 'UNSUBSCRIBE'\n]\n\nmodule.exports = httpMethods\n\n},{}],43:[function(require,module,exports){\n'use strict'\n\n/* eslint-disable no-multi-spaces */\nconst indent              = '    '\nconst branchIndent        = '│   '\nconst midBranchIndent     = '├── '\nconst endBranchIndent     = '└── '\nconst wildcardDelimiter   = '*'\nconst pathDelimiter       = '/'\nconst pathRegExp          = /(?=\\/)/\n/* eslint-enable */\n\nfunction parseFunctionName (fn) {\n  let fName = fn.name || ''\n\n  fName = fName.replace('bound', '').trim()\n  fName = (fName || 'anonymous') + '()'\n  return fName\n}\n\nfunction parseMeta (meta) {\n  if (Array.isArray(meta)) return meta.map(m => parseMeta(m))\n  if (typeof meta === 'symbol') return meta.toString()\n  if (typeof meta === 'function') return parseFunctionName(meta)\n  return meta\n}\n\nfunction buildMetaObject (route, metaArray) {\n  const out = {}\n  const cleanMeta = this.buildPrettyMeta(route)\n  if (!Array.isArray(metaArray)) metaArray = cleanMeta ? Reflect.ownKeys(cleanMeta) : []\n  metaArray.forEach(m => {\n    const metaKey = typeof m === 'symbol' ? m.toString() : m\n    if (cleanMeta && cleanMeta[m]) {\n      out[metaKey] = parseMeta(cleanMeta[m])\n    }\n  })\n  return out\n}\n\nfunction prettyPrintRoutesArray (routeArray, opts = {}) {\n  if (!this.buildPrettyMeta) throw new Error('buildPrettyMeta not defined')\n  opts.includeMeta = opts.includeMeta || null // array of meta objects to display\n  const mergedRouteArray = []\n\n  let tree = ''\n\n  routeArray.sort((a, b) => {\n    if (!a.path || !b.path) return 0\n    return a.path.localeCompare(b.path)\n  })\n\n  // merge alike paths\n  for (let i = 0; i < routeArray.length; i++) {\n    const route = routeArray[i]\n    const pathExists = mergedRouteArray.find(r => route.path === r.path)\n    if (pathExists) {\n      // path already declared, add new method and break out of loop\n      pathExists.handlers.push({\n        method: route.method,\n        opts: route.opts.constraints || undefined,\n        meta: opts.includeMeta ? buildMetaObject.call(this, route, opts.includeMeta) : null\n      })\n      continue\n    }\n\n    const routeHandler = {\n      method: route.method,\n      opts: route.opts.constraints || undefined,\n      meta: opts.includeMeta ? buildMetaObject.call(this, route, opts.includeMeta) : null\n    }\n    mergedRouteArray.push({\n      path: route.path,\n      methods: [route.method],\n      opts: [route.opts],\n      handlers: [routeHandler]\n    })\n  }\n\n  // insert root level path if none defined\n  if (!mergedRouteArray.filter(r => r.path === pathDelimiter).length) {\n    const rootPath = {\n      path: pathDelimiter,\n      truncatedPath: '',\n      methods: [],\n      opts: [],\n      handlers: [{}]\n    }\n\n    // if wildcard route exists, insert root level after wildcard\n    if (mergedRouteArray.filter(r => r.path === wildcardDelimiter).length) {\n      mergedRouteArray.splice(1, 0, rootPath)\n    } else {\n      mergedRouteArray.unshift(rootPath)\n    }\n  }\n\n  // build tree\n  const routeTree = buildRouteTree(mergedRouteArray)\n\n  // draw tree\n  routeTree.forEach((rootBranch, idx) => {\n    tree += drawBranch(rootBranch, null, idx === routeTree.length - 1, false, true)\n    tree += '\\n' // newline characters inserted at beginning of drawing function to allow for nested paths\n  })\n\n  return tree\n}\n\nfunction buildRouteTree (mergedRouteArray) {\n  const result = []\n  const temp = { result }\n  mergedRouteArray.forEach((route, idx) => {\n    let splitPath = route.path.split(pathRegExp)\n\n    // add preceding slash for proper nesting\n    if (splitPath[0] !== pathDelimiter) {\n      // handle wildcard route\n      if (splitPath[0] !== wildcardDelimiter) splitPath = [pathDelimiter, splitPath[0].slice(1), ...splitPath.slice(1)]\n    }\n\n    // build tree\n    splitPath.reduce((acc, path, pidx) => {\n      if (!acc[path]) {\n        acc[path] = { result: [] }\n        const pathSeg = { path, children: acc[path].result }\n\n        if (pidx === splitPath.length - 1) pathSeg.handlers = route.handlers\n        acc.result.push(pathSeg)\n      }\n      return acc[path]\n    }, temp)\n  })\n\n  // unfold root object from array\n  return result\n}\n\nfunction drawBranch (pathSeg, prefix, endBranch, noPrefix, rootBranch) {\n  let branch = ''\n\n  if (!noPrefix && !rootBranch) branch += '\\n'\n  if (!noPrefix) branch += `${prefix || ''}${endBranch ? endBranchIndent : midBranchIndent}`\n  branch += `${pathSeg.path}`\n\n  if (pathSeg.handlers) {\n    const flatHandlers = pathSeg.handlers.reduce((acc, curr) => {\n      const match = acc.findIndex(h => JSON.stringify(h.opts) === JSON.stringify(curr.opts))\n      if (match !== -1) {\n        acc[match].method = [acc[match].method, curr.method].join(', ')\n      } else {\n        acc.push(curr)\n      }\n      return acc\n    }, [])\n\n    flatHandlers.forEach((handler, idx) => {\n      if (idx > 0) branch += `${noPrefix ? '' : prefix || ''}${endBranch ? indent : branchIndent}${pathSeg.path}`\n      branch += ` (${handler.method || '-'})`\n      if (handler.opts && JSON.stringify(handler.opts) !== '{}') branch += ` ${JSON.stringify(handler.opts)}`\n      if (handler.meta) {\n        Reflect.ownKeys(handler.meta).forEach((m, hidx) => {\n          branch += `\\n${noPrefix ? '' : prefix || ''}${endBranch ? indent : branchIndent}`\n          branch += `• (${m}) ${JSON.stringify(handler.meta[m])}`\n        })\n      }\n      if (flatHandlers.length > 1 && idx !== flatHandlers.length - 1) branch += '\\n'\n    })\n  } else {\n    if (pathSeg.children.length > 1) branch += ' (-)'\n  }\n\n  if (!noPrefix) prefix = `${prefix || ''}${endBranch ? indent : branchIndent}`\n\n  pathSeg.children.forEach((child, idx) => {\n    const endBranch = idx === pathSeg.children.length - 1\n    const skipPrefix = (!pathSeg.handlers && pathSeg.children.length === 1)\n    branch += drawBranch(child, prefix, endBranch, skipPrefix)\n  })\n\n  return branch\n}\n\nfunction prettyPrintFlattenedNode (flattenedNode, prefix, tail, opts) {\n  if (!this.buildPrettyMeta) throw new Error('buildPrettyMeta not defined')\n  opts.includeMeta = opts.includeMeta || null // array of meta items to display\n  let paramName = ''\n  const printHandlers = []\n\n  for (const { node, method } of flattenedNode.nodes) {\n    for (const handler of node.handlerStorage.handlers) {\n      printHandlers.push({ method, ...handler })\n    }\n  }\n\n  if (printHandlers.length) {\n    printHandlers.forEach((handler, index) => {\n      let suffix = `(${handler.method || '-'})`\n      if (Object.keys(handler.constraints).length > 0) {\n        suffix += ' ' + JSON.stringify(handler.constraints)\n      }\n\n      let name = ''\n      // find locations of parameters in prefix\n      const paramIndices = flattenedNode.prefix.split('').map((ch, idx) => ch === ':' ? idx : null).filter(idx => idx !== null)\n      if (paramIndices.length) {\n        let prevLoc = 0\n        paramIndices.forEach((loc, idx) => {\n          // find parameter in prefix\n          name += flattenedNode.prefix.slice(prevLoc, loc + 1)\n          // insert parameters\n          name += handler.params[handler.params.length - paramIndices.length + idx]\n          if (idx === paramIndices.length - 1) name += flattenedNode.prefix.slice(loc + 1)\n          prevLoc = loc + 1\n        })\n      } else {\n        // there are no parameters, return full object\n        name = flattenedNode.prefix\n      }\n\n      if (index === 0) {\n        paramName += `${name} ${suffix}`\n      } else {\n        paramName += `\\n${prefix}${tail ? indent : branchIndent}${name} ${suffix}`\n      }\n      if (opts.includeMeta) {\n        const meta = buildMetaObject.call(this, handler, opts.includeMeta)\n        Object.keys(meta).forEach((m, hidx) => {\n          paramName += `\\n${prefix || ''}${tail ? indent : branchIndent}`\n          paramName += `• (${m}) ${JSON.stringify(meta[m])}`\n        })\n      }\n    })\n  } else {\n    paramName = flattenedNode.prefix\n  }\n\n  let tree = `${prefix}${tail ? endBranchIndent : midBranchIndent}${paramName}\\n`\n\n  prefix = `${prefix}${tail ? indent : branchIndent}`\n  const labels = Object.keys(flattenedNode.children)\n  for (let i = 0; i < labels.length; i++) {\n    const child = flattenedNode.children[labels[i]]\n    tree += prettyPrintFlattenedNode.call(this, child, prefix, i === (labels.length - 1), opts)\n  }\n  return tree\n}\n\nfunction flattenNode (flattened, node, method) {\n  if (node.handlerStorage.handlers.length !== 0) {\n    flattened.nodes.push({ method, node })\n  }\n\n  if (node.parametricChildren && node.parametricChildren[0]) {\n    if (!flattened.children[':']) {\n      flattened.children[':'] = {\n        prefix: ':',\n        nodes: [],\n        children: {}\n      }\n    }\n    flattenNode(flattened.children[':'], node.parametricChildren[0], method)\n  }\n\n  if (node.wildcardChild) {\n    if (!flattened.children['*']) {\n      flattened.children['*'] = {\n        prefix: '*',\n        nodes: [],\n        children: {}\n      }\n    }\n    flattenNode(flattened.children['*'], node.wildcardChild, method)\n  }\n\n  if (node.staticChildren) {\n    for (const child of Object.values(node.staticChildren)) {\n      // split on the slash separator but use a regex to lookahead and not actually match it, preserving it in the returned string segments\n      const childPrefixSegments = child.prefix.split(pathRegExp)\n      let cursor = flattened\n      let parent\n      for (const segment of childPrefixSegments) {\n        parent = cursor\n        cursor = cursor.children[segment]\n        if (!cursor) {\n          cursor = {\n            prefix: segment,\n            nodes: [],\n            children: {}\n          }\n          parent.children[segment] = cursor\n        }\n      }\n      flattenNode(cursor, child, method)\n    }\n  }\n}\n\nfunction compressFlattenedNode (flattenedNode) {\n  const childKeys = Object.keys(flattenedNode.children)\n  if (flattenedNode.nodes.length === 0 && childKeys.length === 1) {\n    const child = flattenedNode.children[childKeys[0]]\n    if (child.nodes.length <= 1) {\n      compressFlattenedNode(child)\n      flattenedNode.nodes = child.nodes\n      flattenedNode.prefix += child.prefix\n      flattenedNode.children = child.children\n      return flattenedNode\n    }\n  }\n\n  for (const key of Object.keys(flattenedNode.children)) {\n    compressFlattenedNode(flattenedNode.children[key])\n  }\n\n  return flattenedNode\n}\n\nmodule.exports = { flattenNode, compressFlattenedNode, prettyPrintFlattenedNode, prettyPrintRoutesArray }\n\n},{}],44:[function(require,module,exports){\n'use strict'\nconst assert = require('assert')\n\nfunction HostStorage () {\n  const hosts = {}\n  const regexHosts = []\n  return {\n    get: (host) => {\n      const exact = hosts[host]\n      if (exact) {\n        return exact\n      }\n      for (const regex of regexHosts) {\n        if (regex.host.test(host)) {\n          return regex.value\n        }\n      }\n    },\n    set: (host, value) => {\n      if (host instanceof RegExp) {\n        regexHosts.push({ host, value })\n      } else {\n        hosts[host] = value\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  name: 'host',\n  mustMatchWhenDerived: false,\n  storage: HostStorage,\n  validate (value) {\n    assert(typeof value === 'string' || Object.prototype.toString.call(value) === '[object RegExp]', 'Host should be a string or a RegExp')\n  }\n}\n\n},{\"assert\":1}],45:[function(require,module,exports){\n'use strict'\n\nconst assert = require('assert')\n\nfunction SemVerStore () {\n  if (!(this instanceof SemVerStore)) {\n    return new SemVerStore()\n  }\n\n  this.store = {}\n\n  this.maxMajor = 0\n  this.maxMinors = {}\n  this.maxPatches = {}\n}\n\nSemVerStore.prototype.set = function (version, store) {\n  if (typeof version !== 'string') {\n    throw new TypeError('Version should be a string')\n  }\n  let [major, minor, patch] = version.split('.')\n\n  major = Number(major) || 0\n  minor = Number(minor) || 0\n  patch = Number(patch) || 0\n\n  if (major >= this.maxMajor) {\n    this.maxMajor = major\n    this.store.x = store\n    this.store['*'] = store\n    this.store['x.x'] = store\n    this.store['x.x.x'] = store\n  }\n\n  if (minor >= (this.maxMinors[major] || 0)) {\n    this.maxMinors[major] = minor\n    this.store[`${major}.x`] = store\n    this.store[`${major}.x.x`] = store\n  }\n\n  if (patch >= (this.store[`${major}.${minor}`] || 0)) {\n    this.maxPatches[`${major}.${minor}`] = patch\n    this.store[`${major}.${minor}.x`] = store\n  }\n\n  this.store[`${major}.${minor}.${patch}`] = store\n  return this\n}\n\nSemVerStore.prototype.get = function (version) {\n  return this.store[version]\n}\n\nmodule.exports = {\n  name: 'version',\n  mustMatchWhenDerived: true,\n  storage: SemVerStore,\n  validate (value) {\n    assert(typeof value === 'string', 'Version should be a string')\n  }\n}\n\n},{\"assert\":1}],46:[function(require,module,exports){\n'use strict'\n\n// It must spot all the chars where decodeURIComponent(x) !== decodeURI(x)\n// The chars are: # $ & + , / : ; = ? @\nfunction decodeComponentChar (highCharCode, lowCharCode) {\n  if (highCharCode === 50) {\n    if (lowCharCode === 53) return '%'\n\n    if (lowCharCode === 51) return '#'\n    if (lowCharCode === 52) return '$'\n    if (lowCharCode === 54) return '&'\n    if (lowCharCode === 66) return '+'\n    if (lowCharCode === 98) return '+'\n    if (lowCharCode === 67) return ','\n    if (lowCharCode === 99) return ','\n    if (lowCharCode === 70) return '/'\n    if (lowCharCode === 102) return '/'\n    return null\n  }\n  if (highCharCode === 51) {\n    if (lowCharCode === 65) return ':'\n    if (lowCharCode === 97) return ':'\n    if (lowCharCode === 66) return ';'\n    if (lowCharCode === 98) return ';'\n    if (lowCharCode === 68) return '='\n    if (lowCharCode === 100) return '='\n    if (lowCharCode === 70) return '?'\n    if (lowCharCode === 102) return '?'\n    return null\n  }\n  if (highCharCode === 52 && lowCharCode === 48) {\n    return '@'\n  }\n  return null\n}\n\nfunction safeDecodeURI (path) {\n  let shouldDecode = false\n  let shouldDecodeParam = false\n\n  let querystring = ''\n\n  for (let i = 1; i < path.length; i++) {\n    const charCode = path.charCodeAt(i)\n\n    if (charCode === 37) {\n      const highCharCode = path.charCodeAt(i + 1)\n      const lowCharCode = path.charCodeAt(i + 2)\n\n      if (decodeComponentChar(highCharCode, lowCharCode) === null) {\n        shouldDecode = true\n      } else {\n        shouldDecodeParam = true\n        // %25 - encoded % char. We need to encode one more time to prevent double decoding\n        if (highCharCode === 50 && lowCharCode === 53) {\n          shouldDecode = true\n          path = path.slice(0, i + 1) + '25' + path.slice(i + 1)\n          i += 2\n        }\n        i += 2\n      }\n    // Some systems do not follow RFC and separate the path and query\n    // string with a `;` character (code 59), e.g. `/foo;jsessionid=123456`.\n    // Thus, we need to split on `;` as well as `?` and `#`.\n    } else if (charCode === 63 || charCode === 59 || charCode === 35) {\n      querystring = path.slice(i + 1)\n      path = path.slice(0, i)\n      break\n    }\n  }\n  const decodedPath = shouldDecode ? decodeURI(path) : path\n  return { path: decodedPath, querystring, shouldDecodeParam }\n}\n\nfunction safeDecodeURIComponent (uriComponent) {\n  const startIndex = uriComponent.indexOf('%')\n  if (startIndex === -1) return uriComponent\n\n  let decoded = ''\n  let lastIndex = startIndex\n\n  for (let i = startIndex; i < uriComponent.length; i++) {\n    if (uriComponent.charCodeAt(i) === 37) {\n      const highCharCode = uriComponent.charCodeAt(i + 1)\n      const lowCharCode = uriComponent.charCodeAt(i + 2)\n\n      const decodedChar = decodeComponentChar(highCharCode, lowCharCode)\n      decoded += uriComponent.slice(lastIndex, i) + decodedChar\n\n      lastIndex = i + 3\n    }\n  }\n  return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex)\n}\n\nmodule.exports = { safeDecodeURI, safeDecodeURIComponent }\n\n},{}],47:[function(require,module,exports){\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n},{}],48:[function(require,module,exports){\nclass OratorServiceServerBase\n{\n\tconstructor(pOrator)\n\t{\n\t\tthis.orator = pOrator;\n\n\t\tthis.log = pOrator.log;\n\n\t\tthis.Name = this.orator.settings.Product;\n\t\tthis.URL = 'BASE_SERVICE_SERVER';\n\t\tthis.Port = this.orator.settings.ServicePort;\n\n\t\tthis.Active = false;\n\t}\n\n\t/*\n\t * Service Lifecycle Functions\n\t *************************************************************************/\n\tlisten(pPort, fCallback)\n\t{\n\t\t// Sometimes, listen does not listen on network calls.\n\t\tthis.Active = true;\n\n\t\treturn fCallback();\n\t}\n\n\tclose(fCallback)\n\t{\n\t\tthis.Active = false;\n\n\t\treturn fCallback();\n\t}\n\t/*************************************************************************\n\t * End of Service Lifecycle Functions\n\t */\n\n\n\t/*\n\t * Service Route Creation Functions\n\t *\n\t * These base functions provide basic validation for the routes, but don't actually \n\t * do anything with them.  The design intent here is to allow derived classes to call\n\t * these functions to validate that they conform to expected standards.\n\t *\n\t * Something like:\n\n\t\tget (pRoute, ...fRouteProcessingFunctions)\n\t\t{\n\t\t\tif (!super.get(pRoute, ...fRouteProcessingFunctions))\n\t\t\t{\n\t\t\t\tthis.log.error(`Restify provider failed to map route [${pRoute}]!`);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t//...now we can do our actual get mapping function!....\n\t\t}\n\n\t * This pattern and calling super is totally optional, obviously.\n\t *************************************************************************/\n\tget(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (typeof(pRoute) != 'string')\n\t\t{\n\t\t\tthis.log.error(`Orator GET Route mapping failed -- route parameter was ${typeof(pRoute)} instead of a string.`)\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tput(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (typeof(pRoute) != 'string')\n\t\t{\n\t\t\tthis.log.error(`Orator PUT Route mapping failed -- route parameter was ${typeof(pRoute)} instead of a string.`)\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpost(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (typeof(pRoute) != 'string')\n\t\t{\n\t\t\tthis.log.error(`Orator POST Route mapping failed -- route parameter was ${typeof(pRoute)} instead of a string.`)\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tdel(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (typeof(pRoute) != 'string')\n\t\t{\n\t\t\tthis.log.error(`Orator DEL Route mapping failed -- route parameter was ${typeof(pRoute)} instead of a string.`)\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpatch(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (typeof(pRoute) != 'string')\n\t\t{\n\t\t\tthis.log.error(`Orator PATCH Route mapping failed -- route parameter was ${typeof(pRoute)} instead of a string.`)\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\topts(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (typeof(pRoute) != 'string')\n\t\t{\n\t\t\tthis.log.error(`Orator OPTS Route mapping failed -- route parameter was ${typeof(pRoute)} instead of a string.`)\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\thead(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (typeof(pRoute) != 'string')\n\t\t{\n\t\t\tthis.log.error(`Orator HEAD Route mapping failed -- route parameter was ${typeof(pRoute)} instead of a string.`)\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\t/*************************************************************************\n\t * End of Service Route Creation Functions\n\t */\n\n\t// Programmatically invoke a route\n\tinvoke(pMethod, pRoute, pData, fCallback)\n\t{\n\t\t// The base class version of this does nothing\n\t\tthis.log.debug(`Orator invoke called for route [${pRoute}] and landed on the base class; the service provider likely does not implement programmatic invoke capabilities.`, pData);\n\t\treturn false;\n\t}\n}\n\nmodule.exports = OratorServiceServerBase;\n},{}],49:[function(require,module,exports){\n/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\t\t\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\t\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\t\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t}\n}\n\nmodule.exports = Precedent;\n\n},{\"./StringParser.js\":50,\"./WordTree.js\":51}],50:[function(require,module,exports){\n/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\t\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\t\t\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\t\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\t\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\t\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) && \n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)));\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t */\n\tparseString (pString, pParseTree)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t}\n\t\t\n\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n\n},{}],51:[function(require,module,exports){\n/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - The index of the character in the pattern\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {number} pParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n\n},{}],52:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],53:[function(require,module,exports){\n'use strict'\n\nvar parse = require('ret')\nvar types = parse.types\n\nmodule.exports = function (re, opts) {\n  if (!opts) opts = {}\n  var replimit = opts.limit === undefined ? 25 : opts.limit\n\n  if (isRegExp(re)) re = re.source\n  else if (typeof re !== 'string') re = String(re)\n\n  try { re = parse(re) } catch (err) { return false }\n\n  var reps = 0\n  return (function walk (node, starHeight) {\n    var i\n    var ok\n    var len\n\n    if (node.type === types.REPETITION) {\n      starHeight++\n      reps++\n      if (starHeight > 1) return false\n      if (reps > replimit) return false\n    }\n\n    if (node.options) {\n      for (i = 0, len = node.options.length; i < len; i++) {\n        ok = walk({ stack: node.options[i] }, starHeight)\n        if (!ok) return false\n      }\n    }\n    var stack = node.stack || (node.value && node.value.stack)\n    if (!stack) return true\n\n    for (i = 0; i < stack.length; i++) {\n      ok = walk(stack[i], starHeight)\n      if (!ok) return false\n    }\n\n    return true\n  })(re, 0)\n}\n\nfunction isRegExp (x) {\n  return {}.toString.call(x) === '[object RegExp]'\n}\n\n},{\"ret\":54}],54:[function(require,module,exports){\nconst util      = require('./util');\nconst types     = require('./types');\nconst sets      = require('./sets');\nconst positions = require('./positions');\n\n\nmodule.exports = (regexpStr) => {\n  var i = 0, l, c,\n    start = { type: types.ROOT, stack: []},\n\n    // Keep track of last clause/group and stack.\n    lastGroup = start,\n    last = start.stack,\n    groupStack = [];\n\n\n  var repeatErr = (i) => {\n    util.error(regexpStr, `Nothing to repeat at column ${i - 1}`);\n  };\n\n  // Decode a few escaped characters.\n  var str = util.strToChars(regexpStr);\n  l = str.length;\n\n  // Iterate through each character in string.\n  while (i < l) {\n    c = str[i++];\n\n    switch (c) {\n      // Handle escaped characters, inclues a few sets.\n      case '\\\\':\n        c = str[i++];\n\n        switch (c) {\n          case 'b':\n            last.push(positions.wordBoundary());\n            break;\n\n          case 'B':\n            last.push(positions.nonWordBoundary());\n            break;\n\n          case 'w':\n            last.push(sets.words());\n            break;\n\n          case 'W':\n            last.push(sets.notWords());\n            break;\n\n          case 'd':\n            last.push(sets.ints());\n            break;\n\n          case 'D':\n            last.push(sets.notInts());\n            break;\n\n          case 's':\n            last.push(sets.whitespace());\n            break;\n\n          case 'S':\n            last.push(sets.notWhitespace());\n            break;\n\n          default:\n            // Check if c is integer.\n            // In which case it's a reference.\n            if (/\\d/.test(c)) {\n              last.push({ type: types.REFERENCE, value: parseInt(c, 10) });\n\n            // Escaped character.\n            } else {\n              last.push({ type: types.CHAR, value: c.charCodeAt(0) });\n            }\n        }\n\n        break;\n\n\n      // Positionals.\n      case '^':\n        last.push(positions.begin());\n        break;\n\n      case '$':\n        last.push(positions.end());\n        break;\n\n\n      // Handle custom sets.\n      case '[':\n        // Check if this class is 'anti' i.e. [^abc].\n        var not;\n        if (str[i] === '^') {\n          not = true;\n          i++;\n        } else {\n          not = false;\n        }\n\n        // Get all the characters in class.\n        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);\n\n        // Increase index by length of class.\n        i += classTokens[1];\n        last.push({\n          type: types.SET,\n          set: classTokens[0],\n          not,\n        });\n\n        break;\n\n\n      // Class of any character except \\n.\n      case '.':\n        last.push(sets.anyChar());\n        break;\n\n\n      // Push group onto stack.\n      case '(':\n        // Create group.\n        var group = {\n          type: types.GROUP,\n          stack: [],\n          remember: true,\n        };\n\n        c = str[i];\n\n        // If if this is a special kind of group.\n        if (c === '?') {\n          c = str[i + 1];\n          i += 2;\n\n          // Match if followed by.\n          if (c === '=') {\n            group.followedBy = true;\n\n          // Match if not followed by.\n          } else if (c === '!') {\n            group.notFollowedBy = true;\n\n          } else if (c !== ':') {\n            util.error(regexpStr,\n              `Invalid group, character '${c}'` +\n              ` after '?' at column ${i - 1}`);\n          }\n\n          group.remember = false;\n        }\n\n        // Insert subgroup into current group stack.\n        last.push(group);\n\n        // Remember the current group for when the group closes.\n        groupStack.push(lastGroup);\n\n        // Make this new group the current group.\n        lastGroup = group;\n        last = group.stack;\n        break;\n\n\n      // Pop group out of stack.\n      case ')':\n        if (groupStack.length === 0) {\n          util.error(regexpStr, `Unmatched ) at column ${i - 1}`);\n        }\n        lastGroup = groupStack.pop();\n\n        // Check if this group has a PIPE.\n        // To get back the correct last stack.\n        last = lastGroup.options ?\n          lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;\n        break;\n\n\n      // Use pipe character to give more choices.\n      case '|':\n        // Create array where options are if this is the first PIPE\n        // in this clause.\n        if (!lastGroup.options) {\n          lastGroup.options = [lastGroup.stack];\n          delete lastGroup.stack;\n        }\n\n        // Create a new stack and add to options for rest of clause.\n        var stack = [];\n        lastGroup.options.push(stack);\n        last = stack;\n        break;\n\n\n      // Repetition.\n      // For every repetition, remove last element from last stack\n      // then insert back a RANGE object.\n      // This design is chosen because there could be more than\n      // one repetition symbols in a regex i.e. `a?+{2,3}`.\n      case '{':\n        var rs = /^(\\d+)(,(\\d+)?)?\\}/.exec(str.slice(i)), min, max;\n        if (rs !== null) {\n          if (last.length === 0) {\n            repeatErr(i);\n          }\n          min = parseInt(rs[1], 10);\n          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;\n          i += rs[0].length;\n\n          last.push({\n            type: types.REPETITION,\n            min,\n            max,\n            value: last.pop(),\n          });\n        } else {\n          last.push({\n            type: types.CHAR,\n            value: 123,\n          });\n        }\n        break;\n\n      case '?':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: 1,\n          value: last.pop(),\n        });\n        break;\n\n      case '+':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 1,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n      case '*':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n\n      // Default is a character that is not `\\[](){}?+*^$`.\n      default:\n        last.push({\n          type: types.CHAR,\n          value: c.charCodeAt(0),\n        });\n    }\n\n  }\n\n  // Check if any groups have not been closed.\n  if (groupStack.length !== 0) {\n    util.error(regexpStr, 'Unterminated group');\n  }\n\n  return start;\n};\n\nmodule.exports.types = types;\n\n},{\"./positions\":55,\"./sets\":56,\"./types\":57,\"./util\":58}],55:[function(require,module,exports){\nconst types = require('./types');\nexports.wordBoundary = () => ({ type: types.POSITION, value: 'b' });\nexports.nonWordBoundary = () => ({ type: types.POSITION, value: 'B' });\nexports.begin = () => ({ type: types.POSITION, value: '^' });\nexports.end = () => ({ type: types.POSITION, value: '$' });\n\n},{\"./types\":57}],56:[function(require,module,exports){\nconst types = require('./types');\n\nconst INTS = () => [{ type: types.RANGE , from: 48, to: 57 }];\n\nconst WORDS = () => {\n  return [\n    { type: types.CHAR, value: 95 },\n    { type: types.RANGE, from: 97, to: 122 },\n    { type: types.RANGE, from: 65, to: 90 }\n  ].concat(INTS());\n};\n\nconst WHITESPACE = () => {\n  return [\n    { type: types.CHAR, value: 9 },\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 11 },\n    { type: types.CHAR, value: 12 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 32 },\n    { type: types.CHAR, value: 160 },\n    { type: types.CHAR, value: 5760 },\n    { type: types.RANGE, from: 8192, to: 8202 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n    { type: types.CHAR, value: 8239 },\n    { type: types.CHAR, value: 8287 },\n    { type: types.CHAR, value: 12288 },\n    { type: types.CHAR, value: 65279 }\n  ];\n};\n\nconst NOTANYCHAR = () => {\n  return [\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n  ];\n};\n\n// Predefined class objects.\nexports.words = () => ({ type: types.SET, set: WORDS(), not: false });\nexports.notWords = () => ({ type: types.SET, set: WORDS(), not: true });\nexports.ints = () => ({ type: types.SET, set: INTS(), not: false });\nexports.notInts = () => ({ type: types.SET, set: INTS(), not: true });\nexports.whitespace = () => ({ type: types.SET, set: WHITESPACE(), not: false });\nexports.notWhitespace = () => ({ type: types.SET, set: WHITESPACE(), not: true });\nexports.anyChar = () => ({ type: types.SET, set: NOTANYCHAR(), not: true });\n\n},{\"./types\":57}],57:[function(require,module,exports){\nmodule.exports = {\n  ROOT       : 0,\n  GROUP      : 1,\n  POSITION   : 2,\n  SET        : 3,\n  RANGE      : 4,\n  REPETITION : 5,\n  REFERENCE  : 6,\n  CHAR       : 7,\n};\n\n},{}],58:[function(require,module,exports){\nconst types = require('./types');\nconst sets  = require('./sets');\n\n\nconst CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^ ?';\nconst SLSH = { '0': 0, 't': 9, 'n': 10, 'v': 11, 'f': 12, 'r': 13 };\n\n/**\n * Finds character representations in str and convert all to\n * their respective characters\n *\n * @param {String} str\n * @return {String}\n */\nexports.strToChars = function(str) {\n  /* jshint maxlen: false */\n  var chars_regex = /(\\[\\\\b\\])|(\\\\)?\\\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\\\\]^?])|([0tnvfr]))/g;\n  str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {\n    if (lbs) {\n      return s;\n    }\n\n    var code = b ? 8 :\n      a16   ? parseInt(a16, 16) :\n      b16   ? parseInt(b16, 16) :\n      c8    ? parseInt(c8,   8) :\n      dctrl ? CTRL.indexOf(dctrl) :\n      SLSH[eslsh];\n\n    var c = String.fromCharCode(code);\n\n    // Escape special regex characters.\n    if (/[[\\]{}^$.|?*+()]/.test(c)) {\n      c = '\\\\' + c;\n    }\n\n    return c;\n  });\n\n  return str;\n};\n\n\n/**\n * turns class into tokens\n * reads str until it encounters a ] not preceeded by a \\\n *\n * @param {String} str\n * @param {String} regexpStr\n * @return {Array.<Array.<Object>, Number>}\n */\nexports.tokenizeClass = (str, regexpStr) => {\n  /* jshint maxlen: false */\n  var tokens = [];\n  var regexp = /\\\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\\\)(.)|([^\\]\\\\]))-(?:\\\\)?([^\\]]))|(\\])|(?:\\\\)?([^])/g;\n  var rs, c;\n\n\n  while ((rs = regexp.exec(str)) != null) {\n    if (rs[1]) {\n      tokens.push(sets.words());\n\n    } else if (rs[2]) {\n      tokens.push(sets.ints());\n\n    } else if (rs[3]) {\n      tokens.push(sets.whitespace());\n\n    } else if (rs[4]) {\n      tokens.push(sets.notWords());\n\n    } else if (rs[5]) {\n      tokens.push(sets.notInts());\n\n    } else if (rs[6]) {\n      tokens.push(sets.notWhitespace());\n\n    } else if (rs[7]) {\n      tokens.push({\n        type: types.RANGE,\n        from: (rs[8] || rs[9]).charCodeAt(0),\n        to: rs[10].charCodeAt(0),\n      });\n\n    } else if ((c = rs[12])) {\n      tokens.push({\n        type: types.CHAR,\n        value: c.charCodeAt(0),\n      });\n\n    } else {\n      return [tokens, regexp.lastIndex];\n    }\n  }\n\n  exports.error(regexpStr, 'Unterminated character class');\n};\n\n\n/**\n * Shortcut to throw errors.\n *\n * @param {String} regexp\n * @param {String} msg\n */\nexports.error = (regexp, msg) => {\n  throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);\n};\n\n},{\"./sets\":56,\"./types\":57}],59:[function(require,module,exports){\n(function (setImmediate,clearImmediate){(function (){\nvar nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n}).call(this)}).call(this,require(\"timers\").setImmediate,require(\"timers\").clearImmediate)\n\n},{\"process/browser.js\":52,\"timers\":59}],60:[function(require,module,exports){\n/**\n* Simple browser shim loader - assign the npm module to a window global automatically\n*\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libNPMModuleWrapper = require('./Orator.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('Orator'))\n{\n\twindow.Orator = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;\n},{\"./Orator.js\":66}],61:[function(require,module,exports){\n// Simple default configuration for application, when none is provided\n\nmodule.exports = (\n{\n\t\"Product\": \"Unnamed_Service\",\n\t\"ProductVersion\": \"0.0.1\",\n\n\t\"ServicePort\": 8080\n});\n\n\n},{}],62:[function(require,module,exports){\n/**\n* Default Service Server Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the servers that are available without extensions loaded\ngetDefaultServiceServers = () =>\n{\n\tlet tmpDefaultServiceServers = {};\n\n\ttmpDefaultServiceServers.ipc = require('./Orator-ServiceServer-IPC.js');\n\n\ttmpDefaultServiceServers.default = tmpDefaultServiceServers.ipc;\n\n\treturn tmpDefaultServiceServers;\n}\n\nmodule.exports = getDefaultServiceServers();\n},{\"./Orator-ServiceServer-IPC.js\":65}],63:[function(require,module,exports){\n'use strict'\n\n// This is taken directly from the find-my-way documentation for custom constraints and only mildly edited\nconst ipcResponseTypeStrategy = (\n\t{\n\t\t// strategy name for referencing in the route handler `constraints` options\n\t\tname: 'ipc',\n\t\tisAsync: true,\n\n\t\t// storage factory for storing routes in the find-my-way route tree\n\t\tstorage:\n\t\t\t()=>\n\t\t\t{\n\t\t\t\tlet handlers = {};\n\n\t\t\t\treturn (\n\t\t\t\t\t{\n\t\t\t\t\t\tget: (type) => { return handlers[type] || null },\n\t\t\t\t\t\tset: (type, store) => { handlers[type] = store }\n\t\t\t\t\t});\n\t\t\t},\n\n\t\t// function to get the value of the constraint from each incoming request\n\t\tderiveConstraint: (pRequest, pContext, fDone) =>\n\t\t\t{\n\t\t\t\t// If we wanted to deny the IPC request based on a constraint, we would do:\n\t\t\t\t// fDone(new Error(`The request was denied because ____ in the Request object wasn't right...`));\n\t\t\t\treturn fDone(null, 'IPC');\n\t\t\t},\n\n\t\t// optional flag marking if handlers without constraints can match requests that have a value for this constraint\n\t\tmustMatchWhenDerived: true\n\t});\n\nmodule.exports = ipcResponseTypeStrategy;\n},{}],64:[function(require,module,exports){\nclass OratorServiceServerIPCSynthesizedResponse\n{\n\tconstructor(pLog, pRequestGUID)\n\t{\n\t\tthis.log = pLog;\n\n\t\tthis.requestGUID = pRequestGUID;\n\n\t\tthis.responseData = null;\n\t\tthis.responseStatus = -1;\n\t}\n\n\tsend(pData)\n\t{\n\t\tif (typeof(pData) == 'string')\n\t\t{\n\t\t\t// This is a string!  Append it to the responsedata.\n\t\t\tif (this.responseData === null)\n\t\t\t{\n\t\t\t\tthis.responseData = pData;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (typeof(this.responseData) == 'string')\n\t\t\t{\n\t\t\t\tthis.responseData = this.responseData+pData;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.log(`Request ${this.requestGUID} has tried to send() a string value after send()ing data type ${typeof(this.responseData)}.`, pData)\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (typeof(pData) == 'object')\n\t\t{\n\t\t\tif (this.responseData === null)\n\t\t\t{\n\t\t\t\tthis.responseData = JSON.stringify(pData);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (typeof(this.responseData) == 'string')\n\t\t\t{\n\t\t\t\t// TODO: Discuss best way to handle this / if to handle this\n\t\t\t\tthis.responseData += this.responseData+JSON.stringify(pData);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.log(`Request ${this.requestGUID} has tried to send() an object value to be auto stringified after send()ing data type ${typeof(this.responseData)}.`, pData)\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = OratorServiceServerIPCSynthesizedResponse;\n},{}],65:[function(require,module,exports){\nconst libOratorServiceServerBase = require('orator-serviceserver');\n\n// A synthesized response object, for simple IPC.\nconst libOratorServiceServerIPCSynthesizedResponse = require('./Orator-ServiceServer-IPC-SynthesizedResponse.js');\n// A simple constrainer for the find-my-way router since we aren't using any kind of headers to pass version or host\nconst libOratorServiceServerIPCCustomConstrainer = require('./Orator-ServiceServer-IPC-RouterConstrainer.js');\n\n// This library is the default router for our services\nconst libFindMyWay = require('find-my-way');\n//const libAsync = require('async');\nconst libAsyncWaterfall = require(\"async/waterfall\");\nconst libAsyncEachOfSeries = require('async/eachofseries')\n\nclass OratorServiceServerIPC extends libOratorServiceServerBase\n{\n\tconstructor(pOrator)\n\t{\n\t\tsuper(pOrator);\n\n\t\tthis.routerOptions = (this.orator.settings.hasOwnProperty('router_options') && (typeof(this.orator.settings.router_options) == 'object')) ? this.orator.settings.router_options : {};\n\t\tthis.router = libFindMyWay(this.routerOptions);\n\t\tthis.router.addConstraintStrategy(libOratorServiceServerIPCCustomConstrainer);\n\n\t\tthis.URL = 'IPC';\n\n\t\tthis.preBehaviorFunctions = [];\n\t\tthis.behaviorMap = {};\n\t\tthis.postBehaviorFunctions = [];\n\t}\n\n\texecutePreBehaviorFunctions(pRequest, pResponse, fNext)\n\t{\n\t\tlibAsyncEachOfSeries(this.preBehaviorFunctions,\n\t\t\t(fBehaviorFunction, pFunctionIndex, fCallback) =>\n\t\t\t{\n\t\t\t\treturn fBehaviorFunction(pRequest, pResponse, fCallback);\n\t\t\t},\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (pError)\n\t\t\t\t{\n\t\t\t\t\tthis.log.error(`IPC Provider preBehaviorFunction ${pFunctionIndex} failed with error: ${pError}`, pError);\n\t\t\t\t}\n\t\t\t\treturn fNext(pError);\n\t\t\t});\n\t}\n\n\texecutePostBehaviorFunctions(pRequest, pResponse, fNext)\n\t{\n\t\tlibAsyncEachOfSeries(this.postBehaviorFunctions,\n\t\t\t(fBehaviorFunction, pFunctionIndex, fCallback) =>\n\t\t\t{\n\t\t\t\treturn fBehaviorFunction(pRequest, pResponse, fCallback);\n\t\t\t},\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (pError)\n\t\t\t\t{\n\t\t\t\t\tthis.log.error(`IPC Provider postBehaviorFunction ${pFunctionIndex} failed with error: ${pError}`, pError);\n\t\t\t\t}\n\t\t\t\treturn fNext(pError);\n\t\t\t});\n\t}\n\n\t/*\n\t * Service Route Creation Functions\n\t *\n\t * These base functions provide basic validation for the routes, but don't actually \n\t * do anything with them.  The design intent here is to allow derived classes to call\n\t * these functions to validate that they conform to expected standards.\n\t *\n\t * Something like:\n\n\t\tget (pRoute, ...fRouteProcessingFunctions)\n\t\t{\n\t\t\t//...now we can do our actual get mapping function!....\n\t\t}\n\n\t * This pattern and calling super is totally optional, obviously.\n\t *************************************************************************/\n\taddRouteProcessor(pMethod, pRoute, pRouteFunctionArray)\n\t{\n\t\t// We have a constrainer on IPC so we can control channels eventually, if we like.\n\t\t// For now it just makes sure it was added with an IPC service server.\n\t\tthis.router.on(pMethod, pRoute, { constraints: { \"ipc\": \"IPC\" } },\n\t\t\t(pRequest, pResponse, pParameters) =>\n\t\t\t{\n\t\t\t\tlibAsyncWaterfall(\n\t\t\t\t\t[\n\t\t\t\t\t\t(fStageComplete)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Added to make this mimic what we saw with route parsing in the old restify\n\t\t\t\t\t\t\tpRequest.params = pParameters;\n\t\t\t\t\t\t\treturn fStageComplete();\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(fStageComplete)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.executePreBehaviorFunctions(pRequest, pResponse, fStageComplete);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(fStageComplete)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlibAsyncEachOfSeries(pRouteFunctionArray,\n\t\t\t\t\t\t\t\t(fBehaviorFunction, pFunctionIndex, fCallback) =>\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\treturn fBehaviorFunction(pRequest, pResponse, fCallback);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t(pBehaviorFunctionError) =>\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (pBehaviorFunctionError)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tthis.log.error(`IPC Provider behavior function ${pFunctionIndex} failed with error: ${pBehaviorFunctionError}`, pBehaviorFunctionError);\n\t\t\t\t\t\t\t\t\t\treturn fNext(pError);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(fStageComplete)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.executePostBehaviorFunctions(pRequest, pResponse, fStageComplete);\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t(pRequestError)=>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pRequestError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.log.error(`IPC Provider behavior function ${pFunctionIndex} failed with error: ${pBehaviorFunctionError}`, pBehaviorFunctionError);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t});\n\n\t\treturn true;\n\t}\n\n\tget(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (!super.get(pRoute, ...fRouteProcessingFunctions))\n\t\t{\n\t\t\tthis.log.error(`IPC provider failed to map GET route [${pRoute}]!`);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.addRouteProcessor('GET', pRoute, Array.from(fRouteProcessingFunctions));\n\t}\n\n\tput(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (!super.get(pRoute, ...fRouteProcessingFunctions))\n\t\t{\n\t\t\tthis.log.error(`IPC provider failed to map PUT route [${pRoute}]!`);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpost(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (!super.get(pRoute, ...fRouteProcessingFunctions))\n\t\t{\n\t\t\tthis.log.error(`IPC provider failed to map POST route [${pRoute}]!`);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tdel(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (!super.get(pRoute, ...fRouteProcessingFunctions))\n\t\t{\n\t\t\tthis.log.error(`IPC provider failed to map DEL route [${pRoute}]!`);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\t/*************************************************************************\n\t * End of Service Route Creation Functions\n\t */\n\n\t// Programmatically invoke a route\n\tinvoke(pMethod, pRoute, pData, fCallback)\n\t{\n\t\t// If the data is skipped and a callback is parameter 3, do the right thing\n\t\tlet tmpCallback = (typeof(fCallback) == 'function') ? fCallback : \n\t\t\t\t\t\t\t(typeof(pData) == 'function') ? pData :\n\t\t\t\t\t\t\t// This is here in case the developer passed no callback and just wants to fire and forget the IPC call which might not be async safe\n\t\t\t\t\t\t\t()=>{};\n\n\t\t// Create a bare minimum request object for IPC to pass to our router\n\t\tlet tmpRequest = (\n\t\t\t{\n\t\t\t\tmethod: pMethod,\n\t\t\t\turl: pRoute,\n\t\t\t\tguid: this.orator.fable.getUUID()\n\t\t\t});\n\n\t\t// Create a container for the IPC response data to be aggregated to from send() methodds\n\t\tlet tmpSynthesizedResponseData = new libOratorServiceServerIPCSynthesizedResponse(this.log, tmpRequest.guid);\n\n\t\treturn this.router.lookup(\n\t\t\ttmpRequest,\n\t\t\ttmpSynthesizedResponseData,\n\t\t\t(pError, pResults)=>\n\t\t\t{\n\t\t\t\tif (pError)\n\t\t\t\t{\n\t\t\t\t\tthis.log.error(`IPC Request Error Request GUID [${tmpRequest.guid}] handling route [${pRoute}]: ${pError}`, {Error: pError, Route: pRoute, Data: pData});\n\t\t\t\t}\n\n\t\t\t\t// by default, send data back through \n\t\t\t\treturn tmpCallback(pError, tmpSynthesizedResponseData.responseData, tmpSynthesizedResponseData, pResults);\n\t\t\t});\n\t}\n}\n\nmodule.exports = OratorServiceServerIPC;\n},{\"./Orator-ServiceServer-IPC-RouterConstrainer.js\":63,\"./Orator-ServiceServer-IPC-SynthesizedResponse.js\":64,\"async/eachofseries\":7,\"async/waterfall\":20,\"find-my-way\":40,\"orator-serviceserver\":48}],66:[function(require,module,exports){\n/**\n* Orator Service Abstraction\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Orator Service\n*/\n\nconst libFable = require('fable');\n\nconst defaultOratorConfiguration = require('./Orator-Default-Configuration.js');\nconst defaultOratorServiceServers = require('./Orator-Default-ServiceServers-Node.js');\n\nclass Orator\n{\n\tconstructor(pFable, pServiceProvider)\n\t{\n\t\t// Need to figure out if pFable is a Fable object or a Settings object or neither\n\t\tif ((typeof(pFable) === 'object') && (pFable instanceof libFable))\n\t\t{\n\t\t\t// We were passed a fully operational fable -- use this\n\t\t\tthis.fable = pFable;\n\t\t}\n\t\telse if (typeof(pFable) == 'object')\n\t\t{\n\t\t\tthis.fable = new libFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = new libFable(defaultOratorConfiguration);\n\t\t}\n\n\t\t// Carry core application requirements into the orator object for simplicity\n\t\tthis.settings = this.fable.settings;\n\t\tthis.log = this.fable.log;\n\n\t\t// Create the empty, important logic containers\n\t\tthis.serviceServer = false;\n\t\tthis.serviceServerProvider = false;\n\n\t\tif (typeof(pServiceProvider) !== 'undefined')\n\t\t{\n\t\t\tthis.serviceServerProvider = pServiceProvider;\n\t\t}\n\n\t\t// Now check to see that the ServicePort is set (this used to be APIServerPort)\n\t\tif (!this.settings.hasOwnProperty('ServicePort'))\n\t\t{\n\t\t\tif (this.settings.hasOwnProperty('APIServerPort'))\n\t\t\t{\n\t\t\t\t// Automatically migrate the legacy APIServerPort to ServicePort\n\t\t\t\tthis.settings.ServicePort = this.fable.settings.APIServerPort;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Default to whatever the ... default is!\n\t\t\t\tthis.settings.ServicePort = defaultOratorConfiguration.ServicePort;\n\t\t\t}\n\t\t}\n\n\t\t// Now check to see that the Product name is set\n\t\tif (!this.settings.hasOwnProperty('Product'))\n\t\t{\n\t\t\tthis.settings.Product = defaultOratorConfiguration.Product;\n\t\t}\n\t}\n\n\tinitializeServiceServer(fNext)\n\t{\n\t\tvar tmpNext = (typeof(fNext) === 'function') ? fNext : ()=>{};\n\n\t\tif (!this.serviceServer)\n\t\t{\n\t\t\t// If the developer hasn't set this to a service provider class of their own choosing, \n\t\t\t// use the built-in network-less one.\n\t\t\tif (!this.serviceServerProvider)\n\t\t\t{\n\t\t\t\tthis.serviceServerProvider = defaultOratorServiceServers.default;\n\t\t\t}\n\n\t\t\tthis.serviceServer = new this.serviceServerProvider(this);\n\n\t\t\t// For legacy reasons, we also will provide this under the \"webServer\" variable.\n\t\t\tthis.webServer = this.serviceServer;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`Orator attempting to initialize a service server after initialization has already completed.`)\n\t\t}\n\t}\n\n\t_startServiceListener(fNext)\n\t{\n\t\treturn this.serviceServer.listen\n\t\t(\n\t\t\tthis.settings.ServicePort,\n\t\t\t(pError)\t=>\n\t\t\t{\n\t\t\t\tthis.log.info(`${this.serviceServer.Name} listening at ${this.serviceServer.URL} port ${this.serviceServer.Port}`);\n\t\t\t\treturn fNext(pError);\n\t\t\t}\n\t\t);\n\t}\n\n\tstartService(fNext)\n\t{\n\t\tvar tmpNext = (typeof(fNext) === 'function') ? fNext : ()=>{};\n\n\t\tif (!this.serviceServer)\n\t\t{\n\t\t\tthis.initializeServiceServer();\n\t\t}\n\n\t\treturn this._startServiceListener(tmpNext);\n\t}\n\n\tstopService(fNext)\n\t{\n\t\tvar tmpNext = (typeof(fNext) === 'function') ? fNext : ()=>{};\n\n\t\tif (!this.serviceServer)\n\t\t{\n\t\t\tlet tmpMessage = `Orator attempting to stop a service server but the service server has not been intialized yet.`;\n\t\t\tthis.log.warn(tmpMessage);\n\t\t\treturn tmpNext(tmpMessage);\n\t\t}\n\n\t\tif (!this.serviceServer.Active)\n\t\t{\n\t\t\tlet tmpMessage = `Orator attempting to stop a service server but the service server is not actively running.`;\n\t\t\tthis.log.warn(tmpMessage);\n\t\t\treturn tmpNext(tmpMessage);\n\t\t}\n\n\t\treturn this.serviceServer.close(tmpNext);\n\t}\n\n\tinvoke(pMethod, pRoute, pData, fCallback)\n\t{\n\t\treturn this.serviceServer.invoke(pMethod, pRoute, pData, fCallback);\n\t}\n\n\n\t/*\n\t * Legacy Orator Functions\n\t *************************************************************************/\n\tstartWebServer(fNext)\n\t{\n\t\treturn this.startService(fNext);\n\t}\n\n\t// For legacy purposes\n\tstopWebServer(fNext)\n\t{\n\t\treturn this.stopService(fNext);\n\t}\n\n\t// For legacy purposes\n\tgetWebServer()\n\t{\n\t\t// The old behavior was to lazily construct the service the first time \n\t\t// this accessor function is called.\n\t\tif (!this.serviceServer)\n\t\t{\n\t\t\tthis.initializeServiceServer();\n\t\t}\n\n\t\treturn this.serviceServer;\n\t}\n\t/*************************************************************************\n\t * End of Legacy Orator Functions\n\t */\n}\n\nmodule.exports = Orator;\n\n},{\"./Orator-Default-Configuration.js\":61,\"./Orator-Default-ServiceServers-Node.js\":62,\"fable\":31}]},{},[60])(60)\n});\n\n","'use strict';\n\nvar objectAssign = require('object-assign');\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n// NB: The URL to the CommonJS spec is kept just for tradition.\n//     node-assert has evolved a lot since then, both in API and behavior.\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util/');\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\n// Expose a strict only variant of assert\nfunction strict(value, message) {\n  if (!value) fail(value, true, message, '==', strict);\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = asyncify;\n\nvar _initialParams = require('./internal/initialParams.js');\n\nvar _initialParams2 = _interopRequireDefault(_initialParams);\n\nvar _setImmediate = require('./internal/setImmediate.js');\n\nvar _setImmediate2 = _interopRequireDefault(_setImmediate);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    if ((0, _wrapAsync.isAsync)(func)) {\n        return function (...args /*, callback*/) {\n            const callback = args.pop();\n            const promise = func.apply(this, args);\n            return handlePromise(promise, callback);\n        };\n    }\n\n    return (0, _initialParams2.default)(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (result && typeof result.then === 'function') {\n            return handlePromise(result, callback);\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nfunction handlePromise(promise, callback) {\n    return promise.then(value => {\n        invokeCallback(callback, null, value);\n    }, err => {\n        invokeCallback(callback, err && err.message ? err : new Error(err));\n    });\n}\n\nfunction invokeCallback(callback, error, value) {\n    try {\n        callback(error, value);\n    } catch (err) {\n        (0, _setImmediate2.default)(e => {\n            throw e;\n        }, err);\n    }\n}\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _eachOfLimit2 = require('./internal/eachOfLimit.js');\n\nvar _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _awaitify = require('./internal/awaitify.js');\n\nvar _awaitify2 = _interopRequireDefault(_awaitify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name eachOfLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachOfLimit(coll, limit, iteratee, callback) {\n  return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);\n}\n\nexports.default = (0, _awaitify2.default)(eachOfLimit, 4);\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _eachOfLimit = require('./eachOfLimit.js');\n\nvar _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);\n\nvar _awaitify = require('./internal/awaitify.js');\n\nvar _awaitify2 = _interopRequireDefault(_awaitify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n *\n * @name eachOfSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfSeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachOfSeries(coll, iteratee, callback) {\n  return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);\n}\nexports.default = (0, _awaitify2.default)(eachOfSeries, 3);\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = asyncEachOfLimit;\n\nvar _breakLoop = require('./breakLoop.js');\n\nvar _breakLoop2 = _interopRequireDefault(_breakLoop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// for async generators\nfunction asyncEachOfLimit(generator, limit, iteratee, callback) {\n    let done = false;\n    let canceled = false;\n    let awaiting = false;\n    let running = 0;\n    let idx = 0;\n\n    function replenish() {\n        //console.log('replenish')\n        if (running >= limit || awaiting || done) return;\n        //console.log('replenish awaiting')\n        awaiting = true;\n        generator.next().then(({ value, done: iterDone }) => {\n            //console.log('got value', value)\n            if (canceled || done) return;\n            awaiting = false;\n            if (iterDone) {\n                done = true;\n                if (running <= 0) {\n                    //console.log('done nextCb')\n                    callback(null);\n                }\n                return;\n            }\n            running++;\n            iteratee(value, idx, iterateeCallback);\n            idx++;\n            replenish();\n        }).catch(handleError);\n    }\n\n    function iterateeCallback(err, result) {\n        //console.log('iterateeCallback')\n        running -= 1;\n        if (canceled) return;\n        if (err) return handleError(err);\n\n        if (err === false) {\n            done = true;\n            canceled = true;\n            return;\n        }\n\n        if (result === _breakLoop2.default || done && running <= 0) {\n            done = true;\n            //console.log('done iterCb')\n            return callback(null);\n        }\n        replenish();\n    }\n\n    function handleError(err) {\n        if (canceled) return;\n        awaiting = false;\n        done = true;\n        callback(err);\n    }\n\n    replenish();\n}\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = awaitify;\n// conditionally promisify a function.\n// only return a promise if a callback is omitted\nfunction awaitify(asyncFn, arity = asyncFn.length) {\n    if (!arity) throw new Error('arity is undefined');\n    function awaitable(...args) {\n        if (typeof args[arity - 1] === 'function') {\n            return asyncFn.apply(this, args);\n        }\n\n        return new Promise((resolve, reject) => {\n            args[arity - 1] = (err, ...cbArgs) => {\n                if (err) return reject(err);\n                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);\n            };\n            asyncFn.apply(this, args);\n        });\n    }\n\n    return awaitable;\n}\nmodule.exports = exports['default'];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nconst breakLoop = {};\nexports.default = breakLoop;\nmodule.exports = exports[\"default\"];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _once = require('./once.js');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _iterator = require('./iterator.js');\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _onlyOnce = require('./onlyOnce.js');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./wrapAsync.js');\n\nvar _asyncEachOfLimit = require('./asyncEachOfLimit.js');\n\nvar _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);\n\nvar _breakLoop = require('./breakLoop.js');\n\nvar _breakLoop2 = _interopRequireDefault(_breakLoop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = limit => {\n    return (obj, iteratee, callback) => {\n        callback = (0, _once2.default)(callback);\n        if (limit <= 0) {\n            throw new RangeError('concurrency limit cannot be less than 1');\n        }\n        if (!obj) {\n            return callback(null);\n        }\n        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {\n            return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);\n        }\n        if ((0, _wrapAsync.isAsyncIterable)(obj)) {\n            return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);\n        }\n        var nextElem = (0, _iterator2.default)(obj);\n        var done = false;\n        var canceled = false;\n        var running = 0;\n        var looping = false;\n\n        function iterateeCallback(err, value) {\n            if (canceled) return;\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            } else if (err === false) {\n                done = true;\n                canceled = true;\n            } else if (value === _breakLoop2.default || done && running <= 0) {\n                done = true;\n                return callback(null);\n            } else if (!looping) {\n                replenish();\n            }\n        }\n\n        function replenish() {\n            looping = true;\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));\n            }\n            looping = false;\n        }\n\n        replenish();\n    };\n};\n\nmodule.exports = exports['default'];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (coll) {\n    return coll[Symbol.iterator] && coll[Symbol.iterator]();\n};\n\nmodule.exports = exports[\"default\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (fn) {\n    return function (...args /*, callback*/) {\n        var callback = args.pop();\n        return fn.call(this, args, callback);\n    };\n};\n\nmodule.exports = exports[\"default\"];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = isArrayLike;\nfunction isArrayLike(value) {\n    return value && typeof value.length === 'number' && value.length >= 0 && value.length % 1 === 0;\n}\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = createIterator;\n\nvar _isArrayLike = require('./isArrayLike.js');\n\nvar _isArrayLike2 = _interopRequireDefault(_isArrayLike);\n\nvar _getIterator = require('./getIterator.js');\n\nvar _getIterator2 = _interopRequireDefault(_getIterator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? { value: coll[i], key: i } : null;\n    };\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done) return null;\n        i++;\n        return { value: item.value, key: i };\n    };\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = obj ? Object.keys(obj) : [];\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        if (key === '__proto__') {\n            return next();\n        }\n        return i < len ? { value: obj[key], key } : null;\n    };\n}\n\nfunction createIterator(coll) {\n    if ((0, _isArrayLike2.default)(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = (0, _getIterator2.default)(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\nmodule.exports = exports['default'];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = once;\nfunction once(fn) {\n    function wrapper(...args) {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    }\n    Object.assign(wrapper, fn);\n    return wrapper;\n}\nmodule.exports = exports[\"default\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = onlyOnce;\nfunction onlyOnce(fn) {\n    return function (...args) {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    };\n}\nmodule.exports = exports[\"default\"];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.fallback = fallback;\nexports.wrap = wrap;\n/* istanbul ignore file */\n\nvar hasQueueMicrotask = exports.hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;\nvar hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return (fn, ...args) => defer(() => fn(...args));\n}\n\nvar _defer;\n\nif (hasQueueMicrotask) {\n    _defer = queueMicrotask;\n} else if (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nexports.default = wrap(_defer);","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = undefined;\n\nvar _asyncify = require('../asyncify.js');\n\nvar _asyncify2 = _interopRequireDefault(_asyncify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isAsync(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction isAsyncGenerator(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncGenerator';\n}\n\nfunction isAsyncIterable(obj) {\n    return typeof obj[Symbol.asyncIterator] === 'function';\n}\n\nfunction wrapAsync(asyncFn) {\n    if (typeof asyncFn !== 'function') throw new Error('expected a function');\n    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;\n}\n\nexports.default = wrapAsync;\nexports.isAsync = isAsync;\nexports.isAsyncGenerator = isAsyncGenerator;\nexports.isAsyncIterable = isAsyncIterable;","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _once = require('./internal/once.js');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _onlyOnce = require('./internal/onlyOnce.js');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _awaitify = require('./internal/awaitify.js');\n\nvar _awaitify2 = _interopRequireDefault(_awaitify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nfunction waterfall(tasks, callback) {\n    callback = (0, _once2.default)(callback);\n    if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);\n        task(...args, (0, _onlyOnce2.default)(next));\n    }\n\n    function next(err, ...args) {\n        if (err === false) return;\n        if (err || taskIndex === tasks.length) {\n            return callback(err, ...args);\n        }\n        nextTask(args);\n    }\n\n    nextTask([]);\n}\n\nexports.default = (0, _awaitify2.default)(waterfall);\nmodule.exports = exports['default'];","/**\n* Base Logger Class\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nclass BaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = pLogStreamSettings;\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n","/**\n* Default Logger Provider Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\ngetDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();","module.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]","let libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = pLogStreamSettings.hasOwnProperty('showtimestamps') ? (pLogStreamSettings.showtimestamps == true) : false;\n\t\tthis._FormattedTimeStamps = pLogStreamSettings.hasOwnProperty('formattedtimestamps') ? (pLogStreamSettings.formattedtimestamps == true) : false;\n\n\t\tthis._ContextMessage = pLogStreamSettings.hasOwnProperty('Context') ? `(${pLogStreamSettings.Context})` : \n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = pLogStreamSettings.hasOwnProperty('outputloglinestoconsole') ? pLogStreamSettings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = pLogStreamSettings.hasOwnProperty('outputobjectstoconsole') ? pLogStreamSettings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;","/**\n* Fable Logging Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Logger\n*/\n\n/**\n* Fable Solution Log Wrapper Main Class\n*\n* @class FableLog\n* @constructor\n*/\nclass FableLog\n{\n\tconstructor(pFableSettings, pFable)\n\t{\n\t\tlet tmpSettings = (typeof(pFableSettings) === 'object') ? pFableSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableLog(pSettings);\n}\n\n\nmodule.exports = {new:autoConstruct, FableLog:FableLog};\n","module.exports={\n\t\"Product\": \"ApplicationNameHere\",\n\t\"ProductVersion\": \"0.0.0\",\n\n\t\"ConfigFile\": false,\n\n\t\"LogStreams\":\n\t[\n\t\t{\n\t\t\t\"level\": \"trace\"\n\t\t}\n\t]\n}\n","/**\n* Fable Settings Template Processor\n*\n* This class allows environment variables to come in via templated expressions, and defaults to be set.\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nclass FableSettingsTemplateProcessor\n{\n\tconstructor(pDependencies)\n\t{\n        // Use a no-dependencies templating engine to parse out environment variables\n\t\tthis.templateProcessor = new pDependencies.precedent();\n\n        // TODO: Make the environment variable wrap expression demarcation characters configurable?\n\t\tthis.templateProcessor.addPattern('${', '}',\n\t\t\t(pTemplateValue)=>\n\t\t\t{\n\t\t\t\tlet tmpTemplateValue = pTemplateValue.trim();\n\n\t\t\t\tlet tmpSeparatorIndex = tmpTemplateValue.indexOf('|');\n\n\t\t\t\t// If there is no pipe, the default value will end up being whatever the variable name is.\n\t\t\t\tlet tmpDefaultValue = tmpTemplateValue.substring(tmpSeparatorIndex+1);\n\n\t\t\t\tlet tmpEnvironmentVariableName = (tmpSeparatorIndex > -1) ? tmpTemplateValue.substring(0, tmpSeparatorIndex) : tmpTemplateValue;\n\n\t\t\t\tif (process.env.hasOwnProperty(tmpEnvironmentVariableName))\n\t\t\t\t{\n\t\t\t\t\treturn process.env[tmpEnvironmentVariableName];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpDefaultValue;\n\t\t\t\t}\n\t\t\t});\n    }\n\n    parseSetting(pString)\n    {\n        return this.templateProcessor.parseString(pString);\n    }\n}\n\nmodule.exports = FableSettingsTemplateProcessor;","/**\n* Fable Settings Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nconst libPrecedent = require('precedent');\nconst libFableSettingsTemplateProcessor = require('./Fable-Settings-TemplateProcessor.js');\n\nclass FableSettings\n{\n\tconstructor(pFableSettings)\n\t{\n\t\t// Expose the dependencies for downstream re-use\n\t\tthis.dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libPrecedent\n\t\t\t});\n\n\t\t// Initialize the settings value template processor\n\t\tthis.settingsTemplateProcessor = new libFableSettingsTemplateProcessor(this.dependencies);\n\n\t\t// set straight away so anything that uses it respects the initial setting\n\t\tthis._configureEnvTemplating(pFableSettings);\n\n\t\tthis.default = this.buildDefaultSettings();\n\n\t\t// Construct a new settings object\n\t\tlet tmpSettings = this.merge(pFableSettings, this.buildDefaultSettings());\n\n\t\t// The base settings object (what they were on initialization, before other actors have altered them)\n\t\tthis.base = JSON.parse(JSON.stringify(tmpSettings));\n\n\t\tif (tmpSettings.DefaultConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a DEFAULT configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.DefaultConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tif (tmpSettings.ConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.ConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tthis.settings = tmpSettings;\n\t}\n\n\t// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.\n\tbuildDefaultSettings()\n\t{\n\t\treturn JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));\n\t}\n\n\t// Update the configuration for environment variable templating based on the current settings object\n\t_configureEnvTemplating(pSettings)\n\t{\n\t\t// default environment variable templating to on\n\t\tthis._PerformEnvTemplating = !pSettings || pSettings.NoEnvReplacement !== true;\n\t}\n\n\t// Resolve (recursive) any environment variables found in settings object.\n\t_resolveEnv(pSettings)\n\t{\n\t\tfor (const tmpKey in pSettings)\n\t\t{\n\t\t\tif (typeof(pSettings[tmpKey]) === 'object')\n\t\t\t{\n\t\t\t\tthis._resolveEnv(pSettings[tmpKey]);\n\t\t\t}\n\t\t\telse if (typeof(pSettings[tmpKey]) === 'string')\n\t\t\t{\n\t\t\t\tpSettings[tmpKey] = this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if a value is an object (but not an array).\n\t */\n\t_isObject(value)\n\t{\n\t\treturn typeof(value) === 'object' && !Array.isArray(value);\n\t}\n\n\t/**\n\t * Merge two plain objects. Keys that are objects in both will be merged property-wise.\n\t */\n\t_deepMergeObjects(toObject, fromObject)\n\t{\n\t\tif (!fromObject || !this._isObject(fromObject))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tObject.keys(fromObject).forEach((key) =>\n\t\t{\n\t\t\tconst fromValue = fromObject[key];\n\t\t\tif (this._isObject(fromValue))\n\t\t\t{\n\t\t\t\tconst toValue = toObject[key];\n\t\t\t\tif (toValue && this._isObject(toValue))\n\t\t\t\t{\n\t\t\t\t\t// both are objects, so do a recursive merge\n\t\t\t\t\tthis._deepMergeObjects(toValue, fromValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoObject[key] = fromValue;\n\t\t});\n\t\treturn toObject;\n\t}\n\n\t// Merge some new object into the existing settings.\n\tmerge(pSettingsFrom, pSettingsTo)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\t\t// Default to the settings object if none is passed in for the merge.\n\t\tlet tmpSettingsTo = (typeof(pSettingsTo) === 'object') ? pSettingsTo : this.settings;\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\t\ttmpSettingsTo = this._deepMergeObjects(tmpSettingsTo, tmpSettingsFromCopy);\n\n\t\tif (this._PerformEnvTemplating)\n\t\t{\n\t\t\tthis._resolveEnv(tmpSettingsTo);\n\t\t}\n\t\t// Update env tempating config, since we just updated the config object, and it may have changed\n\t\tthis._configureEnvTemplating(tmpSettingsTo);\n\n\t\treturn tmpSettingsTo;\n\t}\n\n\t// Fill in settings gaps without overwriting settings that are already there\n\tfill(pSettingsFrom)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\n\t\tthis.settings = this._deepMergeObjects(tmpSettingsFromCopy, this.settings);\n\n\t\treturn this.settings;\n\t}\n};\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableSettings(pSettings);\n}\n\nmodule.exports = {new:autoConstruct, FableSettings:FableSettings};","/**\n* Random Byte Generator - Browser version\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nclass RandomBytes\n{\n\tconstructor()\n\t{\n\n\t\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n\t\t// implementation. Also, find the complete implementation of crypto on IE11.\n\t\tthis.getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      \t\t(typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\t}\n\n\t// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\tgenerateWhatWGBytes()\n\t{\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tthis.getRandomValues(tmpBuffer);\n\t\treturn tmpBuffer;\n\t}\n\n\t// Math.random()-based (RNG)\n\tgenerateRandomBytes()\n\t{\n\t\t// If all else fails, use Math.random().  It's fast, but is of unspecified\n\t\t// quality.\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tfor (let i = 0, tmpValue; i < 16; i++)\n\t\t{\n\t\t\tif ((i & 0x03) === 0)\n\t\t\t{\n\t\t\t\ttmpValue = Math.random() * 0x100000000;\n\t\t\t}\n\n\t\t\ttmpBuffer[i] = tmpValue >>> ((i & 0x03) << 3) & 0xff;\n\t\t}\n\n\t\treturn tmpBuffer;\n\t}\n\n\tgenerate()\n\t{\n\t\tif (this.getRandomValues)\n\t\t{\n\t\t\treturn this.generateWhatWGBytes();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateRandomBytes();\n\t\t}\n\t}\n}\n\nmodule.exports = RandomBytes;\n","/**\n* Fable UUID Generator\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable UUID\n*/\n\n/**\n* Fable Solution UUID Generation Main Class\n*\n* @class FableUUID\n* @constructor\n*/\n\nvar libRandomByteGenerator = require('./Fable-UUID-Random.js')\n\nclass FableUUID\n{\n\tconstructor(pSettings)\n\t{\n\t\t// Determine if the module is in \"Random UUID Mode\" which means just use the random character function rather than the v4 random UUID spec.\n\t\t// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.\n\t\tthis._UUIDModeRandom = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDModeRandom')) ? (pSettings.UUIDModeRandom == true) : false;\n\t\t// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec\n\t\t// Length for \"Random UUID Mode\" is set -- if not set it to 8\n\t\tthis._UUIDLength = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDLength')) ? (pSettings.UUIDLength + 0) : 8;\n\t\t// Dictionary for \"Random UUID Mode\"\n\t\tthis._UUIDRandomDictionary = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDDictionary')) ? (pSettings.UUIDDictionary + 0) : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n\t\tthis.randomByteGenerator = new libRandomByteGenerator();\n\n\t\t// Lookup table for hex codes\n\t\tthis._HexLookup = [];\n\t\tfor (let i = 0; i < 256; ++i)\n\t\t{\n\t\t\tthis._HexLookup[i] = (i + 0x100).toString(16).substr(1);\n\t\t}\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tbytesToUUID(pBuffer)\n\t{\n\t\tlet i = 0;\n\t\t// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\t\treturn ([\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], \n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]]\n\t\t\t\t]).join('');\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgenerateUUIDv4()\n\t{\n\t\tlet tmpBuffer = new Array(16);\n\t\tvar tmpRandomBytes = this.randomByteGenerator.generate();\n\n\t\t// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t\ttmpRandomBytes[6] = (tmpRandomBytes[6] & 0x0f) | 0x40;\n\t\ttmpRandomBytes[8] = (tmpRandomBytes[8] & 0x3f) | 0x80;\n\n\t\treturn this.bytesToUUID(tmpRandomBytes);\n\t}\n\n\t// Simple random UUID generation\n\tgenerateRandom()\n\t{\n\t\tlet tmpUUID = '';\n\n\t\tfor (let i = 0; i < this._UUIDLength; i++)\n\t\t{\n\t\t\ttmpUUID += this._UUIDRandomDictionary.charAt(Math.floor(Math.random() * (this._UUIDRandomDictionary.length-1)));\n\t\t}\n\n\t\treturn tmpUUID;\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgetUUID()\n\t{\n\t\tif (this._UUIDModeRandom)\n\t\t{\n\t\t\treturn this.generateRandom();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateUUIDv4();\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableUUID(pSettings);\n}\n\n\nmodule.exports = {new:autoConstruct, FableUUID:FableUUID};\n","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libFableSettings = require('fable-settings').FableSettings;\nconst libFableUUID = require('fable-uuid').FableUUID;\nconst libFableLog = require('fable-log').FableLog;\n\n\n/**\n* Fable Application Services Support Library\n*\n* @class Fable\n*/\nclass Fable\n{\n\tconstructor(pSettings)\n\t{\n\t\tlet tmpSettings = new libFableSettings(pSettings);\n\n\t\tthis.settingsManager = tmpSettings;\n\n\t\t// Instantiate the UUID generator\n\t\tthis.libUUID = new libFableUUID(this.settingsManager.settings);\n\n\t\tthis.log = new libFableLog(this.settingsManager.settings);\n\t\tthis.log.initialize();\n\t}\n\n\tget settings()\n\t{\n\t\treturn this.settingsManager.settings;\n\t}\n\n\tget fable()\n\t{\n\t\treturn this;\n\t}\n\n\tgetUUID()\n\t{\n\t\treturn this.libUUID.getUUID();\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new Fable(pSettings);\n}\n\nmodule.exports = Fable;\n","'use strict'\n\nvar UTF8_ACCEPT = 12\nvar UTF8_REJECT = 0\nvar UTF8_DATA = [\n  // The first part of the table maps bytes to character to a transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,\n  10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\n  // The second part of the table maps a state to a new state when adding a\n  // transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96,\n  0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\n  // The third part maps the current transition to a mask that needs to apply\n  // to the byte.\n  0x7F, 0x3F, 0x3F, 0x3F, 0x00, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07\n]\n\nfunction decodeURIComponent (uri) {\n  var percentPosition = uri.indexOf('%')\n  if (percentPosition === -1) return uri\n\n  var length = uri.length\n  var decoded = ''\n  var last = 0\n  var codepoint = 0\n  var startOfOctets = percentPosition\n  var state = UTF8_ACCEPT\n\n  while (percentPosition > -1 && percentPosition < length) {\n    var high = hexCodeToInt(uri[percentPosition + 1], 4)\n    var low = hexCodeToInt(uri[percentPosition + 2], 0)\n    var byte = high | low\n    var type = UTF8_DATA[byte]\n    state = UTF8_DATA[256 + state + type]\n    codepoint = (codepoint << 6) | (byte & UTF8_DATA[364 + type])\n\n    if (state === UTF8_ACCEPT) {\n      decoded += uri.slice(last, startOfOctets)\n\n      decoded += (codepoint <= 0xFFFF)\n        ? String.fromCharCode(codepoint)\n        : String.fromCharCode(\n          (0xD7C0 + (codepoint >> 10)),\n          (0xDC00 + (codepoint & 0x3FF))\n        )\n\n      codepoint = 0\n      last = percentPosition + 3\n      percentPosition = startOfOctets = uri.indexOf('%', last)\n    } else if (state === UTF8_REJECT) {\n      return null\n    } else {\n      percentPosition += 3\n      if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue\n      return null\n    }\n  }\n\n  return decoded + uri.slice(last)\n}\n\nvar HEX = {\n  '0': 0,\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  '4': 4,\n  '5': 5,\n  '6': 6,\n  '7': 7,\n  '8': 8,\n  '9': 9,\n  'a': 10,\n  'A': 10,\n  'b': 11,\n  'B': 11,\n  'c': 12,\n  'C': 12,\n  'd': 13,\n  'D': 13,\n  'e': 14,\n  'E': 14,\n  'f': 15,\n  'F': 15\n}\n\nfunction hexCodeToInt (c, shift) {\n  var i = HEX[c]\n  return i === undefined ? 255 : i << shift\n}\n\nmodule.exports = decodeURIComponent\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","\"use strict\";\n\nconst parse = require(\"./parse\");\nconst stringify = require(\"./stringify\");\n\nconst fastQuerystring = {\n  parse,\n  stringify,\n};\n\n/**\n * Enable TS and JS support\n *\n * - `const qs = require('fast-querystring')`\n * - `import qs from 'fast-querystring'`\n */\nmodule.exports = fastQuerystring;\nmodule.exports.default = fastQuerystring;\nmodule.exports.parse = parse;\nmodule.exports.stringify = stringify;\n","// This file is taken from Node.js project.\n// Full implementation can be found from https://github.com/nodejs/node/blob/main/lib/internal/querystring.js\n\nconst hexTable = Array.from(\n  { length: 256 },\n  (_, i) => \"%\" + ((i < 16 ? \"0\" : \"\") + i.toString(16)).toUpperCase(),\n);\n\n// These characters do not need escaping when generating query strings:\n// ! - . _ ~\n// ' ( ) *\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\n// rome-ignore format: the array should not be formatted\nconst noEscape = new Int8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 80 - 95\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, // 112 - 127\n]);\n\n/**\n * @param {string} str\n * @returns {string}\n */\nfunction encodeString(str) {\n  const len = str.length;\n  if (len === 0) return \"\";\n\n  let out = \"\";\n  let lastPos = 0;\n  let i = 0;\n\n  outer: for (; i < len; i++) {\n    let c = str.charCodeAt(i);\n\n    // ASCII\n    while (c < 0x80) {\n      if (noEscape[c] !== 1) {\n        if (lastPos < i) out += str.slice(lastPos, i);\n        lastPos = i + 1;\n        out += hexTable[c];\n      }\n\n      if (++i === len) break outer;\n\n      c = str.charCodeAt(i);\n    }\n\n    if (lastPos < i) out += str.slice(lastPos, i);\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += hexTable[0xc0 | (c >> 6)] + hexTable[0x80 | (c & 0x3f)];\n      continue;\n    }\n    if (c < 0xd800 || c >= 0xe000) {\n      lastPos = i + 1;\n      out +=\n        hexTable[0xe0 | (c >> 12)] +\n        hexTable[0x80 | ((c >> 6) & 0x3f)] +\n        hexTable[0x80 | (c & 0x3f)];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n\n    // This branch should never happen because all URLSearchParams entries\n    // should already be converted to USVString. But, included for\n    // completion's sake anyway.\n    if (i >= len) {\n      throw new Error(\"URI malformed\");\n    }\n\n    const c2 = str.charCodeAt(i) & 0x3ff;\n\n    lastPos = i + 1;\n    c = 0x10000 + (((c & 0x3ff) << 10) | c2);\n    out +=\n      hexTable[0xf0 | (c >> 18)] +\n      hexTable[0x80 | ((c >> 12) & 0x3f)] +\n      hexTable[0x80 | ((c >> 6) & 0x3f)] +\n      hexTable[0x80 | (c & 0x3f)];\n  }\n  if (lastPos === 0) return str;\n  if (lastPos < len) return out + str.slice(lastPos);\n  return out;\n}\n\nmodule.exports = { encodeString };\n","\"use strict\";\n\nconst fastDecode = require(\"fast-decode-uri-component\");\n\nconst plusRegex = /\\+/g;\nconst Empty = function () {};\nEmpty.prototype = Object.create(null);\n\n/**\n * @callback parse\n * @param {string} input\n */\nfunction parse(input) {\n  // Optimization: Use new Empty() instead of Object.create(null) for performance\n  // v8 has a better optimization for initializing functions compared to Object\n  const result = new Empty();\n\n  if (typeof input !== \"string\") {\n    return result;\n  }\n\n  let inputLength = input.length;\n  let key = \"\";\n  let value = \"\";\n  let startingIndex = -1;\n  let equalityIndex = -1;\n  let shouldDecodeKey = false;\n  let shouldDecodeValue = false;\n  let keyHasPlus = false;\n  let valueHasPlus = false;\n  let hasBothKeyValuePair = false;\n  let c = 0;\n\n  // Have a boundary of input.length + 1 to access last pair inside the loop.\n  for (let i = 0; i < inputLength + 1; i++) {\n    c = i !== inputLength ? input.charCodeAt(i) : 38;\n\n    // Handle '&' and end of line to pass the current values to result\n    if (c === 38) {\n      hasBothKeyValuePair = equalityIndex > startingIndex;\n\n      // Optimization: Reuse equality index to store the end of key\n      if (!hasBothKeyValuePair) {\n        equalityIndex = i;\n      }\n\n      key = input.slice(startingIndex + 1, equalityIndex);\n\n      // Add key/value pair only if the range size is greater than 1; a.k.a. contains at least \"=\"\n      if (hasBothKeyValuePair || key.length > 0) {\n        // Optimization: Replace '+' with space\n        if (keyHasPlus) {\n          key = key.replace(plusRegex, \" \");\n        }\n\n        // Optimization: Do not decode if it's not necessary.\n        if (shouldDecodeKey) {\n          key = fastDecode(key) || key;\n        }\n\n        if (hasBothKeyValuePair) {\n          value = input.slice(equalityIndex + 1, i);\n\n          if (valueHasPlus) {\n            value = value.replace(plusRegex, \" \");\n          }\n\n          if (shouldDecodeValue) {\n            value = fastDecode(value) || value;\n          }\n        }\n        const currentValue = result[key];\n\n        if (currentValue === undefined) {\n          result[key] = value;\n        } else {\n          // Optimization: value.pop is faster than Array.isArray(value)\n          if (currentValue.pop) {\n            currentValue.push(value);\n          } else {\n            result[key] = [currentValue, value];\n          }\n        }\n      }\n\n      // Reset reading key value pairs\n      value = \"\";\n      startingIndex = i;\n      equalityIndex = i;\n      shouldDecodeKey = false;\n      shouldDecodeValue = false;\n      keyHasPlus = false;\n      valueHasPlus = false;\n    }\n    // Check '='\n    else if (c === 61) {\n      if (equalityIndex <= startingIndex) {\n        equalityIndex = i;\n      }\n      // If '=' character occurs again, we should decode the input.\n      else {\n        shouldDecodeValue = true;\n      }\n    }\n    // Check '+', and remember to replace it with empty space.\n    else if (c === 43) {\n      if (equalityIndex > startingIndex) {\n        valueHasPlus = true;\n      } else {\n        keyHasPlus = true;\n      }\n    }\n    // Check '%' character for encoding\n    else if (c === 37) {\n      if (equalityIndex > startingIndex) {\n        shouldDecodeValue = true;\n      } else {\n        shouldDecodeKey = true;\n      }\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = parse;\n","\"use strict\";\n\nconst { encodeString } = require(\"./internals/querystring\");\n\nfunction getAsPrimitive(value) {\n  const type = typeof value;\n\n  if (type === \"string\") {\n    // Length check is handled inside encodeString function\n    return encodeString(value);\n  } else if (type === \"bigint\") {\n    return value.toString();\n  } else if (type === \"boolean\") {\n    return value ? \"true\" : \"false\";\n  } else if (type === \"number\" && Number.isFinite(value)) {\n    return value < 1e21 ? \"\" + value : encodeString(\"\" + value);\n  }\n\n  return \"\";\n}\n\n/**\n * @param {Record<string, string | number | boolean\n * | ReadonlyArray<string | number | boolean> | null>} input\n * @returns {string}\n */\nfunction stringify(input) {\n  let result = \"\";\n\n  if (input === null || typeof input !== \"object\") {\n    return result;\n  }\n\n  const separator = \"&\";\n  const keys = Object.keys(input);\n  const keyLength = keys.length;\n  let valueLength = 0;\n\n  for (let i = 0; i < keyLength; i++) {\n    const key = keys[i];\n    const value = input[key];\n    const encodedKey = encodeString(key) + \"=\";\n\n    if (i) {\n      result += separator;\n    }\n\n    if (Array.isArray(value)) {\n      valueLength = value.length;\n      for (let j = 0; j < valueLength; j++) {\n        if (j) {\n          result += separator;\n        }\n\n        // Optimization: Dividing into multiple lines improves the performance.\n        // Since v8 does not need to care about the '+' character if it was one-liner.\n        result += encodedKey;\n        result += getAsPrimitive(value[j]);\n      }\n    } else {\n      result += encodedKey;\n      result += getAsPrimitive(value);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = stringify;\n","'use strict'\n\nconst HandlerStorage = require('./handler_storage')\n\nconst NODE_TYPES = {\n  STATIC: 0,\n  PARAMETRIC: 1,\n  WILDCARD: 2\n}\n\nclass Node {\n  constructor () {\n    this.handlerStorage = new HandlerStorage()\n  }\n}\n\nclass ParentNode extends Node {\n  constructor () {\n    super()\n    this.staticChildren = {}\n  }\n\n  findStaticMatchingChild (path, pathIndex) {\n    const staticChild = this.staticChildren[path.charAt(pathIndex)]\n    if (staticChild === undefined || !staticChild.matchPrefix(path, pathIndex)) {\n      return null\n    }\n    return staticChild\n  }\n\n  createStaticChild (path) {\n    if (path.length === 0) {\n      return this\n    }\n\n    let staticChild = this.staticChildren[path.charAt(0)]\n    if (staticChild) {\n      let i = 1\n      for (; i < staticChild.prefix.length; i++) {\n        if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {\n          staticChild = staticChild.split(this, i)\n          break\n        }\n      }\n      return staticChild.createStaticChild(path.slice(i))\n    }\n\n    const label = path.charAt(0)\n    this.staticChildren[label] = new StaticNode(path)\n    return this.staticChildren[label]\n  }\n}\n\nclass StaticNode extends ParentNode {\n  constructor (prefix) {\n    super()\n    this.prefix = prefix\n    this.wildcardChild = null\n    this.parametricChildren = []\n    this.kind = NODE_TYPES.STATIC\n    this._compilePrefixMatch()\n  }\n\n  createParametricChild (regex, staticSuffix) {\n    const regexpSource = regex && regex.source\n\n    let parametricChild = this.parametricChildren.find(child => {\n      const childRegexSource = child.regex && child.regex.source\n      return childRegexSource === regexpSource\n    })\n\n    if (parametricChild) {\n      return parametricChild\n    }\n\n    parametricChild = new ParametricNode(regex, staticSuffix)\n    this.parametricChildren.push(parametricChild)\n    this.parametricChildren.sort((child1, child2) => {\n      if (!child1.isRegex) return 1\n      if (!child2.isRegex) return -1\n\n      if (child1.staticSuffix === null) return 1\n      if (child2.staticSuffix === null) return -1\n\n      if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1\n      if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1\n\n      return 0\n    })\n\n    return parametricChild\n  }\n\n  createWildcardChild () {\n    if (this.wildcardChild) {\n      return this.wildcardChild\n    }\n\n    this.wildcardChild = new WildcardNode()\n    return this.wildcardChild\n  }\n\n  split (parentNode, length) {\n    const parentPrefix = this.prefix.slice(0, length)\n    const childPrefix = this.prefix.slice(length)\n\n    this.prefix = childPrefix\n    this._compilePrefixMatch()\n\n    const staticNode = new StaticNode(parentPrefix)\n    staticNode.staticChildren[childPrefix.charAt(0)] = this\n    parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode\n\n    return staticNode\n  }\n\n  getNextNode (path, pathIndex, nodeStack, paramsCount) {\n    let node = this.findStaticMatchingChild(path, pathIndex)\n    let parametricBrotherNodeIndex = 0\n\n    if (node === null) {\n      if (this.parametricChildren.length === 0) {\n        return this.wildcardChild\n      }\n\n      node = this.parametricChildren[0]\n      parametricBrotherNodeIndex = 1\n    }\n\n    if (this.wildcardChild !== null) {\n      nodeStack.push({\n        paramsCount,\n        brotherPathIndex: pathIndex,\n        brotherNode: this.wildcardChild\n      })\n    }\n\n    for (let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--) {\n      nodeStack.push({\n        paramsCount,\n        brotherPathIndex: pathIndex,\n        brotherNode: this.parametricChildren[i]\n      })\n    }\n\n    return node\n  }\n\n  _compilePrefixMatch () {\n    if (this.prefix.length === 1) {\n      this.matchPrefix = () => true\n      return\n    }\n\n    const lines = []\n    for (let i = 1; i < this.prefix.length; i++) {\n      const charCode = this.prefix.charCodeAt(i)\n      lines.push(`path.charCodeAt(i + ${i}) === ${charCode}`)\n    }\n    this.matchPrefix = new Function('path', 'i', `return ${lines.join(' && ')}`) // eslint-disable-line\n  }\n}\n\nclass ParametricNode extends ParentNode {\n  constructor (regex, staticSuffix) {\n    super()\n    this.isRegex = !!regex\n    this.regex = regex || null\n    this.staticSuffix = staticSuffix || null\n    this.kind = NODE_TYPES.PARAMETRIC\n  }\n\n  getNextNode (path, pathIndex) {\n    return this.findStaticMatchingChild(path, pathIndex)\n  }\n}\n\nclass WildcardNode extends Node {\n  constructor () {\n    super()\n    this.kind = NODE_TYPES.WILDCARD\n  }\n\n  getNextNode () {\n    return null\n  }\n}\n\nmodule.exports = { StaticNode, ParametricNode, WildcardNode, NODE_TYPES }\n","'use strict'\n\nclass HandlerStorage {\n  constructor () {\n    this.unconstrainedHandler = null // optimized reference to the handler that will match most of the time\n    this.constraints = []\n    this.handlers = [] // unoptimized list of handler objects for which the fast matcher function will be compiled\n    this.constrainedHandlerStores = null\n  }\n\n  // This is the hot path for node handler finding -- change with care!\n  getMatchingHandler (derivedConstraints) {\n    if (derivedConstraints === undefined) {\n      return this.unconstrainedHandler\n    }\n    return this._getHandlerMatchingConstraints(derivedConstraints)\n  }\n\n  addHandler (handler, params, store, constrainer, constraints) {\n    const handlerObject = {\n      handler,\n      params,\n      constraints,\n      store: store || null,\n      _createParamsObject: this._compileCreateParamsObject(params)\n    }\n\n    if (Object.keys(constraints).length === 0) {\n      this.unconstrainedHandler = handlerObject\n    }\n\n    for (const constraint of Object.keys(constraints)) {\n      if (!this.constraints.includes(constraint)) {\n        if (constraint === 'version') {\n          // always check the version constraint first as it is the most selective\n          this.constraints.unshift(constraint)\n        } else {\n          this.constraints.push(constraint)\n        }\n      }\n    }\n\n    if (this.handlers.length >= 32) {\n      throw new Error('find-my-way supports a maximum of 32 route handlers per node when there are constraints, limit reached')\n    }\n\n    this.handlers.push(handlerObject)\n    // Sort the most constrained handlers to the front of the list of handlers so they are tested first.\n    this.handlers.sort((a, b) => Object.keys(a.constraints).length - Object.keys(b.constraints).length)\n\n    this._compileGetHandlerMatchingConstraints(constrainer, constraints)\n  }\n\n  _compileCreateParamsObject (params) {\n    const lines = []\n    for (let i = 0; i < params.length; i++) {\n      lines.push(`'${params[i]}': paramsArray[${i}]`)\n    }\n    return new Function('paramsArray', `return {${lines.join(',')}}`)  // eslint-disable-line\n  }\n\n  _getHandlerMatchingConstraints () {\n    return null\n  }\n\n  // Builds a store object that maps from constraint values to a bitmap of handler indexes which pass the constraint for a value\n  // So for a host constraint, this might look like { \"fastify.io\": 0b0010, \"google.ca\": 0b0101 }, meaning the 3rd handler is constrainted to fastify.io, and the 2nd and 4th handlers are constrained to google.ca.\n  // The store's implementation comes from the strategies provided to the Router.\n  _buildConstraintStore (store, constraint) {\n    for (let i = 0; i < this.handlers.length; i++) {\n      const handler = this.handlers[i]\n      const constraintValue = handler.constraints[constraint]\n      if (constraintValue !== undefined) {\n        let indexes = store.get(constraintValue) || 0\n        indexes |= 1 << i // set the i-th bit for the mask because this handler is constrained by this value https://stackoverflow.com/questions/1436438/how-do-you-set-clear-and-toggle-a-single-bit-in-javascrip\n        store.set(constraintValue, indexes)\n      }\n    }\n  }\n\n  // Builds a bitmask for a given constraint that has a bit for each handler index that is 0 when that handler *is* constrained and 1 when the handler *isnt* constrainted. This is opposite to what might be obvious, but is just for convienience when doing the bitwise operations.\n  _constrainedIndexBitmask (constraint) {\n    let mask = 0\n    for (let i = 0; i < this.handlers.length; i++) {\n      const handler = this.handlers[i]\n      const constraintValue = handler.constraints[constraint]\n      if (constraintValue !== undefined) {\n        mask |= 1 << i\n      }\n    }\n    return ~mask\n  }\n\n  // Compile a fast function to match the handlers for this node\n  // The function implements a general case multi-constraint matching algorithm.\n  // The general idea is this: we have a bunch of handlers, each with a potentially different set of constraints, and sometimes none at all. We're given a list of constraint values and we have to use the constraint-value-comparison strategies to see which handlers match the constraint values passed in.\n  // We do this by asking each constraint store which handler indexes match the given constraint value for each store. Trickily, the handlers that a store says match are the handlers constrained by that store, but handlers that aren't constrained at all by that store could still match just fine. So, each constraint store can only describe matches for it, and it won't have any bearing on the handlers it doesn't care about. For this reason, we have to ask each stores which handlers match and track which have been matched (or not cared about) by all of them.\n  // We use bitmaps to represent these lists of matches so we can use bitwise operations to implement this efficiently. Bitmaps are cheap to allocate, let us implement this masking behaviour in one CPU instruction, and are quite compact in memory. We start with a bitmap set to all 1s representing every handler that is a match candidate, and then for each constraint, see which handlers match using the store, and then mask the result by the mask of handlers that that store applies to, and bitwise AND with the candidate list. Phew.\n  // We consider all this compiling function complexity to be worth it, because the naive implementation that just loops over the handlers asking which stores match is quite a bit slower.\n  _compileGetHandlerMatchingConstraints (constrainer) {\n    this.constrainedHandlerStores = {}\n\n    for (const constraint of this.constraints) {\n      const store = constrainer.newStoreForConstraint(constraint)\n      this.constrainedHandlerStores[constraint] = store\n\n      this._buildConstraintStore(store, constraint)\n    }\n\n    const lines = []\n    lines.push(`\n    let candidates = ${(1 << this.handlers.length) - 1}\n    let mask, matches\n    `)\n    for (const constraint of this.constraints) {\n      // Setup the mask for indexes this constraint applies to. The mask bits are set to 1 for each position if the constraint applies.\n      lines.push(`\n      mask = ${this._constrainedIndexBitmask(constraint)}\n      value = derivedConstraints.${constraint}\n      `)\n\n      // If there's no constraint value, none of the handlers constrained by this constraint can match. Remove them from the candidates.\n      // If there is a constraint value, get the matching indexes bitmap from the store, and mask it down to only the indexes this constraint applies to, and then bitwise and with the candidates list to leave only matching candidates left.\n      const strategy = constrainer.strategies[constraint]\n      const matchMask = strategy.mustMatchWhenDerived ? 'matches' : '(matches | mask)'\n\n      lines.push(`\n      if (value === undefined) {\n        candidates &= mask\n      } else {\n        matches = this.constrainedHandlerStores.${constraint}.get(value) || 0\n        candidates &= ${matchMask}\n      }\n      if (candidates === 0) return null;\n      `)\n    }\n\n    // There are some constraints that can be derived and marked as \"must match\", where if they are derived, they only match routes that actually have a constraint on the value, like the SemVer version constraint.\n    // An example: a request comes in for version 1.x, and this node has a handler that matches the path, but there's no version constraint. For SemVer, the find-my-way semantics do not match this handler to that request.\n    // This function is used by Nodes with handlers to match when they don't have any constrained routes to exclude request that do have must match derived constraints present.\n    for (const constraint in constrainer.strategies) {\n      const strategy = constrainer.strategies[constraint]\n      if (strategy.mustMatchWhenDerived && !this.constraints.includes(constraint)) {\n        lines.push(`if (derivedConstraints.${constraint} !== undefined) return null`)\n      }\n    }\n\n    // Return the first handler who's bit is set in the candidates https://stackoverflow.com/questions/18134985/how-to-find-index-of-first-set-bit\n    lines.push('return this.handlers[Math.floor(Math.log2(candidates))]')\n\n    this._getHandlerMatchingConstraints = new Function('derivedConstraints', lines.join('\\n')) // eslint-disable-line\n  }\n}\n\nmodule.exports = HandlerStorage\n","'use strict'\n\n/*\n  Char codes:\n    '!': 33 - !\n    '#': 35 - %23\n    '$': 36 - %24\n    '%': 37 - %25\n    '&': 38 - %26\n    ''': 39 - '\n    '(': 40 - (\n    ')': 41 - )\n    '*': 42 - *\n    '+': 43 - %2B\n    ',': 44 - %2C\n    '-': 45 - -\n    '.': 46 - .\n    '/': 47 - %2F\n    ':': 58 - %3A\n    ';': 59 - %3B\n    '=': 61 - %3D\n    '?': 63 - %3F\n    '@': 64 - %40\n    '_': 95 - _\n    '~': 126 - ~\n*/\n\nconst assert = require('assert')\nconst querystring = require('fast-querystring')\nconst isRegexSafe = require('safe-regex2')\nconst deepEqual = require('fast-deep-equal')\nconst { flattenNode, compressFlattenedNode, prettyPrintFlattenedNode, prettyPrintRoutesArray } = require('./lib/pretty-print')\nconst { StaticNode, NODE_TYPES } = require('./custom_node')\nconst Constrainer = require('./lib/constrainer')\nconst httpMethods = require('./lib/http-methods')\nconst { safeDecodeURI, safeDecodeURIComponent } = require('./lib/url-sanitizer')\n\nconst FULL_PATH_REGEXP = /^https?:\\/\\/.*?\\//\nconst OPTIONAL_PARAM_REGEXP = /(\\/:[^/()]*?)\\?(\\/?)/\n\nif (!isRegexSafe(FULL_PATH_REGEXP)) {\n  throw new Error('the FULL_PATH_REGEXP is not safe, update this module')\n}\n\nif (!isRegexSafe(OPTIONAL_PARAM_REGEXP)) {\n  throw new Error('the OPTIONAL_PARAM_REGEXP is not safe, update this module')\n}\n\nfunction Router (opts) {\n  if (!(this instanceof Router)) {\n    return new Router(opts)\n  }\n  opts = opts || {}\n\n  if (opts.defaultRoute) {\n    assert(typeof opts.defaultRoute === 'function', 'The default route must be a function')\n    this.defaultRoute = opts.defaultRoute\n  } else {\n    this.defaultRoute = null\n  }\n\n  if (opts.onBadUrl) {\n    assert(typeof opts.onBadUrl === 'function', 'The bad url handler must be a function')\n    this.onBadUrl = opts.onBadUrl\n  } else {\n    this.onBadUrl = null\n  }\n\n  if (opts.buildPrettyMeta) {\n    assert(typeof opts.buildPrettyMeta === 'function', 'buildPrettyMeta must be a function')\n    this.buildPrettyMeta = opts.buildPrettyMeta\n  } else {\n    this.buildPrettyMeta = defaultBuildPrettyMeta\n  }\n\n  if (opts.querystringParser) {\n    assert(typeof opts.querystringParser === 'function', 'querystringParser must be a function')\n    this.querystringParser = opts.querystringParser\n  } else {\n    this.querystringParser = (query) => query === '' ? {} : querystring.parse(query)\n  }\n\n  this.caseSensitive = opts.caseSensitive === undefined ? true : opts.caseSensitive\n  this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false\n  this.ignoreDuplicateSlashes = opts.ignoreDuplicateSlashes || false\n  this.maxParamLength = opts.maxParamLength || 100\n  this.allowUnsafeRegex = opts.allowUnsafeRegex || false\n  this.routes = []\n  this.trees = {}\n  this.constrainer = new Constrainer(opts.constraints)\n\n  this._routesPatterns = {}\n}\n\nRouter.prototype.on = function on (method, path, opts, handler, store) {\n  if (typeof opts === 'function') {\n    if (handler !== undefined) {\n      store = handler\n    }\n    handler = opts\n    opts = {}\n  }\n  // path validation\n  assert(typeof path === 'string', 'Path should be a string')\n  assert(path.length > 0, 'The path could not be empty')\n  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`')\n  // handler validation\n  assert(typeof handler === 'function', 'Handler should be a function')\n\n  // path ends with optional parameter\n  const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP)\n  if (optionalParamMatch) {\n    assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, 'Optional Parameter needs to be the last parameter of the path')\n\n    const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, '$1$2')\n    const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, '$2')\n\n    this.on(method, pathFull, opts, handler, store)\n    this.on(method, pathOptional, opts, handler, store)\n    return\n  }\n\n  const route = path\n\n  if (this.ignoreDuplicateSlashes) {\n    path = removeDuplicateSlashes(path)\n  }\n\n  if (this.ignoreTrailingSlash) {\n    path = trimLastSlash(path)\n  }\n\n  const methods = Array.isArray(method) ? method : [method]\n  for (const method of methods) {\n    this._on(method, path, opts, handler, store, route)\n    this.routes.push({ method, path, opts, handler, store })\n  }\n}\n\nRouter.prototype._on = function _on (method, path, opts, handler, store) {\n  assert(typeof method === 'string', 'Method should be a string')\n  assert(httpMethods.includes(method), `Method '${method}' is not an http method.`)\n\n  let constraints = {}\n  if (opts.constraints !== undefined) {\n    assert(typeof opts.constraints === 'object' && opts.constraints !== null, 'Constraints should be an object')\n    if (Object.keys(opts.constraints).length !== 0) {\n      constraints = opts.constraints\n    }\n  }\n\n  this.constrainer.validateConstraints(constraints)\n  // Let the constrainer know if any constraints are being used now\n  this.constrainer.noteUsage(constraints)\n\n  // Boot the tree for this method if it doesn't exist yet\n  if (this.trees[method] === undefined) {\n    this.trees[method] = new StaticNode('/')\n    this._routesPatterns[method] = []\n  }\n\n  if (path === '*' && this.trees[method].prefix.length !== 0) {\n    const currentRoot = this.trees[method]\n    this.trees[method] = new StaticNode('')\n    this.trees[method].staticChildren['/'] = currentRoot\n  }\n\n  let currentNode = this.trees[method]\n  let parentNodePathIndex = currentNode.prefix.length\n\n  const params = []\n  for (let i = 0; i <= path.length; i++) {\n    if (path.charCodeAt(i) === 58 && path.charCodeAt(i + 1) === 58) {\n      // It's a double colon\n      i++\n      continue\n    }\n\n    const isParametricNode = path.charCodeAt(i) === 58 && path.charCodeAt(i + 1) !== 58\n    const isWildcardNode = path.charCodeAt(i) === 42\n\n    if (isParametricNode || isWildcardNode || (i === path.length && i !== parentNodePathIndex)) {\n      let staticNodePath = path.slice(parentNodePathIndex, i)\n      if (!this.caseSensitive) {\n        staticNodePath = staticNodePath.toLowerCase()\n      }\n      staticNodePath = staticNodePath.split('::').join(':')\n      staticNodePath = staticNodePath.split('%').join('%25')\n      // add the static part of the route to the tree\n      currentNode = currentNode.createStaticChild(staticNodePath)\n    }\n\n    if (isParametricNode) {\n      let isRegexNode = false\n      const regexps = []\n\n      let lastParamStartIndex = i + 1\n      for (let j = lastParamStartIndex; ; j++) {\n        const charCode = path.charCodeAt(j)\n\n        const isRegexParam = charCode === 40\n        const isStaticPart = charCode === 45 || charCode === 46\n        const isEndOfNode = charCode === 47 || j === path.length\n\n        if (isRegexParam || isStaticPart || isEndOfNode) {\n          const paramName = path.slice(lastParamStartIndex, j)\n          params.push(paramName)\n\n          isRegexNode = isRegexNode || isRegexParam || isStaticPart\n\n          if (isRegexParam) {\n            const endOfRegexIndex = getClosingParenthensePosition(path, j)\n            const regexString = path.slice(j, endOfRegexIndex + 1)\n\n            if (!this.allowUnsafeRegex) {\n              assert(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`)\n            }\n\n            regexps.push(trimRegExpStartAndEnd(regexString))\n\n            j = endOfRegexIndex + 1\n          } else {\n            regexps.push('(.*?)')\n          }\n\n          const staticPartStartIndex = j\n          for (; j < path.length; j++) {\n            const charCode = path.charCodeAt(j)\n            if (charCode === 47) break\n            if (charCode === 58) {\n              const nextCharCode = path.charCodeAt(j + 1)\n              if (nextCharCode === 58) j++\n              else break\n            }\n          }\n\n          let staticPart = path.slice(staticPartStartIndex, j)\n          if (staticPart) {\n            staticPart = staticPart.split('::').join(':')\n            staticPart = staticPart.split('%').join('%25')\n            regexps.push(escapeRegExp(staticPart))\n          }\n\n          lastParamStartIndex = j + 1\n\n          if (isEndOfNode || path.charCodeAt(j) === 47 || j === path.length) {\n            const nodePattern = isRegexNode ? '()' + staticPart : staticPart\n\n            path = path.slice(0, i + 1) + nodePattern + path.slice(j)\n            i += nodePattern.length\n\n            const regex = isRegexNode ? new RegExp('^' + regexps.join('') + '$') : null\n            currentNode = currentNode.createParametricChild(regex, staticPart || null)\n            parentNodePathIndex = i + 1\n            break\n          }\n        }\n      }\n    } else if (isWildcardNode) {\n      // add the wildcard parameter\n      params.push('*')\n      currentNode = currentNode.createWildcardChild()\n      parentNodePathIndex = i + 1\n\n      if (i !== path.length - 1) {\n        throw new Error('Wildcard must be the last character in the route')\n      }\n    }\n  }\n\n  if (!this.caseSensitive) {\n    path = path.toLowerCase()\n  }\n\n  if (path === '*') {\n    path = '/*'\n  }\n\n  for (const existRoute of this._routesPatterns[method]) {\n    if (existRoute.path === path && deepEqual(existRoute.constraints, constraints)) {\n      throw new Error(`Method '${method}' already declared for route '${path}' with constraints '${JSON.stringify(constraints)}'`)\n    }\n  }\n  this._routesPatterns[method].push({ path, params, constraints })\n\n  currentNode.handlerStorage.addHandler(handler, params, store, this.constrainer, constraints)\n}\n\nRouter.prototype.hasConstraintStrategy = function (strategyName) {\n  return this.constrainer.hasConstraintStrategy(strategyName)\n}\n\nRouter.prototype.addConstraintStrategy = function (constraints) {\n  this.constrainer.addConstraintStrategy(constraints)\n  this._rebuild(this.routes)\n}\n\nRouter.prototype.reset = function reset () {\n  this.trees = {}\n  this.routes = []\n  this._routesPatterns = {}\n}\n\nRouter.prototype.off = function off (method, path, constraints) {\n  // path validation\n  assert(typeof path === 'string', 'Path should be a string')\n  assert(path.length > 0, 'The path could not be empty')\n  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`')\n  // options validation\n  assert(\n    typeof constraints === 'undefined' ||\n    (typeof constraints === 'object' && !Array.isArray(constraints) && constraints !== null),\n    'Constraints should be an object or undefined.')\n\n  // path ends with optional parameter\n  const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP)\n  if (optionalParamMatch) {\n    assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, 'Optional Parameter needs to be the last parameter of the path')\n\n    const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, '$1$2')\n    const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, '$2')\n\n    this.off(method, pathFull, constraints)\n    this.off(method, pathOptional, constraints)\n    return\n  }\n\n  if (this.ignoreDuplicateSlashes) {\n    path = removeDuplicateSlashes(path)\n  }\n\n  if (this.ignoreTrailingSlash) {\n    path = trimLastSlash(path)\n  }\n\n  const methods = Array.isArray(method) ? method : [method]\n  for (const method of methods) {\n    this._off(method, path, constraints)\n  }\n}\n\nRouter.prototype._off = function _off (method, path, constraints) {\n  // method validation\n  assert(typeof method === 'string', 'Method should be a string')\n  assert(httpMethods.includes(method), `Method '${method}' is not an http method.`)\n\n  function matcherWithoutConstraints (route) {\n    return method !== route.method || path !== route.path\n  }\n\n  function matcherWithConstraints (route) {\n    return matcherWithoutConstraints(route) || !deepEqual(constraints, route.opts.constraints || {})\n  }\n\n  const predicate = constraints ? matcherWithConstraints : matcherWithoutConstraints\n\n  // Rebuild tree without the specific route\n  const newRoutes = this.routes.filter(predicate)\n  this._rebuild(newRoutes)\n}\n\nRouter.prototype.lookup = function lookup (req, res, ctx, done) {\n  if (typeof ctx === 'function') {\n    done = ctx\n    ctx = undefined\n  }\n\n  if (done === undefined) {\n    const constraints = this.constrainer.deriveConstraints(req, ctx)\n    const handle = this.find(req.method, req.url, constraints)\n    return this.callHandler(handle, req, res, ctx)\n  }\n\n  this.constrainer.deriveConstraints(req, ctx, (err, constraints) => {\n    if (err !== null) {\n      done(err)\n      return\n    }\n\n    try {\n      const handle = this.find(req.method, req.url, constraints)\n      const result = this.callHandler(handle, req, res, ctx)\n      done(null, result)\n    } catch (err) {\n      done(err)\n    }\n  })\n}\n\nRouter.prototype.callHandler = function callHandler (handle, req, res, ctx) {\n  if (handle === null) return this._defaultRoute(req, res, ctx)\n  return ctx === undefined\n    ? handle.handler(req, res, handle.params, handle.store, handle.searchParams)\n    : handle.handler.call(ctx, req, res, handle.params, handle.store, handle.searchParams)\n}\n\nRouter.prototype.find = function find (method, path, derivedConstraints) {\n  let currentNode = this.trees[method]\n  if (currentNode === undefined) return null\n\n  if (path.charCodeAt(0) !== 47) { // 47 is '/'\n    path = path.replace(FULL_PATH_REGEXP, '/')\n  }\n\n  // This must be run before sanitizeUrl as the resulting function\n  // .sliceParameter must be constructed with same URL string used\n  // throughout the rest of this function.\n  if (this.ignoreDuplicateSlashes) {\n    path = removeDuplicateSlashes(path)\n  }\n\n  let sanitizedUrl\n  let querystring\n  let shouldDecodeParam\n\n  try {\n    sanitizedUrl = safeDecodeURI(path)\n    path = sanitizedUrl.path\n    querystring = sanitizedUrl.querystring\n    shouldDecodeParam = sanitizedUrl.shouldDecodeParam\n  } catch (error) {\n    return this._onBadUrl(path)\n  }\n\n  if (this.ignoreTrailingSlash) {\n    path = trimLastSlash(path)\n  }\n\n  const originPath = path\n\n  if (this.caseSensitive === false) {\n    path = path.toLowerCase()\n  }\n\n  const maxParamLength = this.maxParamLength\n\n  let pathIndex = currentNode.prefix.length\n  const params = []\n  const pathLen = path.length\n\n  const brothersNodesStack = []\n\n  while (true) {\n    if (pathIndex === pathLen) {\n      const handle = currentNode.handlerStorage.getMatchingHandler(derivedConstraints)\n\n      if (handle !== null) {\n        return {\n          handler: handle.handler,\n          store: handle.store,\n          params: handle._createParamsObject(params),\n          searchParams: this.querystringParser(querystring)\n        }\n      }\n    }\n\n    let node = currentNode.getNextNode(path, pathIndex, brothersNodesStack, params.length)\n\n    if (node === null) {\n      if (brothersNodesStack.length === 0) {\n        return null\n      }\n\n      const brotherNodeState = brothersNodesStack.pop()\n      pathIndex = brotherNodeState.brotherPathIndex\n      params.splice(brotherNodeState.paramsCount)\n      node = brotherNodeState.brotherNode\n    }\n\n    currentNode = node\n\n    // static route\n    if (currentNode.kind === NODE_TYPES.STATIC) {\n      pathIndex += currentNode.prefix.length\n      continue\n    }\n\n    if (currentNode.kind === NODE_TYPES.WILDCARD) {\n      let param = originPath.slice(pathIndex)\n      if (shouldDecodeParam) {\n        param = safeDecodeURIComponent(param)\n      }\n\n      params.push(param)\n      pathIndex = pathLen\n      continue\n    }\n\n    if (currentNode.kind === NODE_TYPES.PARAMETRIC) {\n      let paramEndIndex = originPath.indexOf('/', pathIndex)\n      if (paramEndIndex === -1) {\n        paramEndIndex = pathLen\n      }\n\n      let param = originPath.slice(pathIndex, paramEndIndex)\n      if (shouldDecodeParam) {\n        param = safeDecodeURIComponent(param)\n      }\n\n      if (currentNode.isRegex) {\n        const matchedParameters = currentNode.regex.exec(param)\n        if (matchedParameters === null) continue\n\n        for (let i = 1; i < matchedParameters.length; i++) {\n          const matchedParam = matchedParameters[i]\n          if (matchedParam.length > maxParamLength) {\n            return null\n          }\n          params.push(matchedParam)\n        }\n      } else {\n        if (param.length > maxParamLength) {\n          return null\n        }\n        params.push(param)\n      }\n\n      pathIndex = paramEndIndex\n    }\n  }\n}\n\nRouter.prototype._rebuild = function (routes) {\n  this.reset()\n\n  for (const route of routes) {\n    const { method, path, opts, handler, store } = route\n    this._on(method, path, opts, handler, store)\n    this.routes.push({ method, path, opts, handler, store })\n  }\n}\n\nRouter.prototype._defaultRoute = function (req, res, ctx) {\n  if (this.defaultRoute !== null) {\n    return ctx === undefined\n      ? this.defaultRoute(req, res)\n      : this.defaultRoute.call(ctx, req, res)\n  } else {\n    res.statusCode = 404\n    res.end()\n  }\n}\n\nRouter.prototype._onBadUrl = function (path) {\n  if (this.onBadUrl === null) {\n    return null\n  }\n  const onBadUrl = this.onBadUrl\n  return {\n    handler: (req, res, ctx) => onBadUrl(path, req, res),\n    params: {},\n    store: null\n  }\n}\n\nRouter.prototype.prettyPrint = function (opts = {}) {\n  opts.commonPrefix = opts.commonPrefix === undefined ? true : opts.commonPrefix // default to original behaviour\n  if (!opts.commonPrefix) return prettyPrintRoutesArray.call(this, this.routes, opts)\n  const root = {\n    prefix: '/',\n    nodes: [],\n    children: {}\n  }\n\n  for (const method in this.trees) {\n    const node = this.trees[method]\n    if (node) {\n      flattenNode(root, node, method)\n    }\n  }\n\n  compressFlattenedNode(root)\n\n  return prettyPrintFlattenedNode.call(this, root, '', true, opts)\n}\n\nfor (var i in httpMethods) {\n  /* eslint no-prototype-builtins: \"off\" */\n  if (!httpMethods.hasOwnProperty(i)) continue\n  const m = httpMethods[i]\n  const methodName = m.toLowerCase()\n\n  if (Router.prototype[methodName]) throw new Error('Method already exists: ' + methodName)\n\n  Router.prototype[methodName] = function (path, handler, store) {\n    return this.on(m, path, handler, store)\n  }\n}\n\nRouter.prototype.all = function (path, handler, store) {\n  this.on(httpMethods, path, handler, store)\n}\n\nmodule.exports = Router\n\nfunction escapeRegExp (string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction removeDuplicateSlashes (path) {\n  return path.replace(/\\/\\/+/g, '/')\n}\n\nfunction trimLastSlash (path) {\n  if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {\n    return path.slice(0, -1)\n  }\n  return path\n}\n\nfunction trimRegExpStartAndEnd (regexString) {\n  // removes chars that marks start \"^\" and end \"$\" of regexp\n  if (regexString.charCodeAt(1) === 94) {\n    regexString = regexString.slice(0, 1) + regexString.slice(2)\n  }\n\n  if (regexString.charCodeAt(regexString.length - 2) === 36) {\n    regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1)\n  }\n\n  return regexString\n}\n\nfunction getClosingParenthensePosition (path, idx) {\n  // `path.indexOf()` will always return the first position of the closing parenthese,\n  // but it's inefficient for grouped or wrong regexp expressions.\n  // see issues #62 and #63 for more info\n\n  var parentheses = 1\n\n  while (idx < path.length) {\n    idx++\n\n    // ignore skipped chars\n    if (path[idx] === '\\\\') {\n      idx++\n      continue\n    }\n\n    if (path[idx] === ')') {\n      parentheses--\n    } else if (path[idx] === '(') {\n      parentheses++\n    }\n\n    if (!parentheses) return idx\n  }\n\n  throw new TypeError('Invalid regexp expression in \"' + path + '\"')\n}\n\nfunction defaultBuildPrettyMeta (route) {\n  // buildPrettyMeta function must return an object, which will be parsed into key/value pairs for display\n  if (!route) return {}\n  if (!route.store) return {}\n  return Object.assign({}, route.store)\n}\n","'use strict'\n\nconst acceptVersionStrategy = require('./strategies/accept-version')\nconst acceptHostStrategy = require('./strategies/accept-host')\nconst assert = require('assert')\n\nclass Constrainer {\n  constructor (customStrategies) {\n    this.strategies = {\n      version: acceptVersionStrategy,\n      host: acceptHostStrategy\n    }\n\n    this.strategiesInUse = new Set()\n    this.asyncStrategiesInUse = new Set()\n\n    // validate and optimize prototypes of given custom strategies\n    if (customStrategies) {\n      for (const strategy of Object.values(customStrategies)) {\n        this.addConstraintStrategy(strategy)\n      }\n    }\n  }\n\n  isStrategyUsed (strategyName) {\n    return this.strategiesInUse.has(strategyName) ||\n      this.asyncStrategiesInUse.has(strategyName)\n  }\n\n  hasConstraintStrategy (strategyName) {\n    const customConstraintStrategy = this.strategies[strategyName]\n    if (customConstraintStrategy !== undefined) {\n      return customConstraintStrategy.isCustom ||\n        this.isStrategyUsed(strategyName)\n    }\n    return false\n  }\n\n  addConstraintStrategy (strategy) {\n    assert(typeof strategy.name === 'string' && strategy.name !== '', 'strategy.name is required.')\n    assert(strategy.storage && typeof strategy.storage === 'function', 'strategy.storage function is required.')\n    assert(strategy.deriveConstraint && typeof strategy.deriveConstraint === 'function', 'strategy.deriveConstraint function is required.')\n\n    if (this.strategies[strategy.name] && this.strategies[strategy.name].isCustom) {\n      throw new Error(`There already exists a custom constraint with the name ${strategy.name}.`)\n    }\n\n    if (this.isStrategyUsed(strategy.name)) {\n      throw new Error(`There already exists a route with ${strategy.name} constraint.`)\n    }\n\n    strategy.isCustom = true\n    strategy.isAsync = strategy.deriveConstraint.length === 3\n    this.strategies[strategy.name] = strategy\n\n    if (strategy.mustMatchWhenDerived) {\n      this.noteUsage({ [strategy.name]: strategy })\n    }\n  }\n\n  deriveConstraints (req, ctx, done) {\n    const constraints = this.deriveSyncConstraints(req, ctx)\n\n    if (done === undefined) {\n      return constraints\n    }\n\n    this.deriveAsyncConstraints(constraints, req, ctx, done)\n  }\n\n  deriveSyncConstraints (req, ctx) {\n    return undefined\n  }\n\n  // When new constraints start getting used, we need to rebuild the deriver to derive them. Do so if we see novel constraints used.\n  noteUsage (constraints) {\n    if (constraints) {\n      const beforeSize = this.strategiesInUse.size\n      for (const key in constraints) {\n        const strategy = this.strategies[key]\n        if (strategy.isAsync) {\n          this.asyncStrategiesInUse.add(key)\n        } else {\n          this.strategiesInUse.add(key)\n        }\n      }\n      if (beforeSize !== this.strategiesInUse.size) {\n        this._buildDeriveConstraints()\n      }\n    }\n  }\n\n  newStoreForConstraint (constraint) {\n    if (!this.strategies[constraint]) {\n      throw new Error(`No strategy registered for constraint key ${constraint}`)\n    }\n    return this.strategies[constraint].storage()\n  }\n\n  validateConstraints (constraints) {\n    for (const key in constraints) {\n      const value = constraints[key]\n      if (typeof value === 'undefined') {\n        throw new Error('Can\\'t pass an undefined constraint value, must pass null or no key at all')\n      }\n      const strategy = this.strategies[key]\n      if (!strategy) {\n        throw new Error(`No strategy registered for constraint key ${key}`)\n      }\n      if (strategy.validate) {\n        strategy.validate(value)\n      }\n    }\n  }\n\n  deriveAsyncConstraints (constraints, req, ctx, done) {\n    let asyncConstraintsCount = this.asyncStrategiesInUse.size\n\n    if (asyncConstraintsCount === 0) {\n      done(null, constraints)\n      return\n    }\n\n    constraints = constraints || {}\n    for (const key of this.asyncStrategiesInUse) {\n      const strategy = this.strategies[key]\n      strategy.deriveConstraint(req, ctx, (err, constraintValue) => {\n        if (err !== null) {\n          done(err)\n          return\n        }\n\n        constraints[key] = constraintValue\n\n        if (--asyncConstraintsCount === 0) {\n          done(null, constraints)\n        }\n      })\n    }\n  }\n\n  // Optimization: build a fast function for deriving the constraints for all the strategies at once. We inline the definitions of the version constraint and the host constraint for performance.\n  // If no constraining strategies are in use (no routes constrain on host, or version, or any custom strategies) then we don't need to derive constraints for each route match, so don't do anything special, and just return undefined\n  // This allows us to not allocate an object to hold constraint values if no constraints are defined.\n  _buildDeriveConstraints () {\n    if (this.strategiesInUse.size === 0) return\n\n    const lines = ['return {']\n\n    for (const key of this.strategiesInUse) {\n      const strategy = this.strategies[key]\n      // Optimization: inline the derivation for the common built in constraints\n      if (!strategy.isCustom) {\n        if (key === 'version') {\n          lines.push('   version: req.headers[\\'accept-version\\'],')\n        } else if (key === 'host') {\n          lines.push('   host: req.headers.host || req.headers[\\':authority\\'],')\n        } else {\n          throw new Error('unknown non-custom strategy for compiling constraint derivation function')\n        }\n      } else {\n        lines.push(`  ${strategy.name}: this.strategies.${key}.deriveConstraint(req, ctx),`)\n      }\n    }\n\n    lines.push('}')\n\n    this.deriveSyncConstraints = new Function('req', 'ctx', lines.join('\\n')).bind(this) // eslint-disable-line\n  }\n}\n\nmodule.exports = Constrainer\n","'use strict'\n\n// defined by Node.js http module, a snapshot from Node.js 18.12.0\nconst httpMethods = [\n  'ACL', 'BIND', 'CHECKOUT', 'CONNECT', 'COPY', 'DELETE',\n  'GET', 'HEAD', 'LINK', 'LOCK', 'M-SEARCH', 'MERGE',\n  'MKACTIVITY', 'MKCALENDAR', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS',\n  'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT',\n  'REBIND', 'REPORT', 'SEARCH', 'SOURCE', 'SUBSCRIBE', 'TRACE',\n  'UNBIND', 'UNLINK', 'UNLOCK', 'UNSUBSCRIBE'\n]\n\nmodule.exports = httpMethods\n","'use strict'\n\n/* eslint-disable no-multi-spaces */\nconst indent              = '    '\nconst branchIndent        = '│   '\nconst midBranchIndent     = '├── '\nconst endBranchIndent     = '└── '\nconst wildcardDelimiter   = '*'\nconst pathDelimiter       = '/'\nconst pathRegExp          = /(?=\\/)/\n/* eslint-enable */\n\nfunction parseFunctionName (fn) {\n  let fName = fn.name || ''\n\n  fName = fName.replace('bound', '').trim()\n  fName = (fName || 'anonymous') + '()'\n  return fName\n}\n\nfunction parseMeta (meta) {\n  if (Array.isArray(meta)) return meta.map(m => parseMeta(m))\n  if (typeof meta === 'symbol') return meta.toString()\n  if (typeof meta === 'function') return parseFunctionName(meta)\n  return meta\n}\n\nfunction buildMetaObject (route, metaArray) {\n  const out = {}\n  const cleanMeta = this.buildPrettyMeta(route)\n  if (!Array.isArray(metaArray)) metaArray = cleanMeta ? Reflect.ownKeys(cleanMeta) : []\n  metaArray.forEach(m => {\n    const metaKey = typeof m === 'symbol' ? m.toString() : m\n    if (cleanMeta && cleanMeta[m]) {\n      out[metaKey] = parseMeta(cleanMeta[m])\n    }\n  })\n  return out\n}\n\nfunction prettyPrintRoutesArray (routeArray, opts = {}) {\n  if (!this.buildPrettyMeta) throw new Error('buildPrettyMeta not defined')\n  opts.includeMeta = opts.includeMeta || null // array of meta objects to display\n  const mergedRouteArray = []\n\n  let tree = ''\n\n  routeArray.sort((a, b) => {\n    if (!a.path || !b.path) return 0\n    return a.path.localeCompare(b.path)\n  })\n\n  // merge alike paths\n  for (let i = 0; i < routeArray.length; i++) {\n    const route = routeArray[i]\n    const pathExists = mergedRouteArray.find(r => route.path === r.path)\n    if (pathExists) {\n      // path already declared, add new method and break out of loop\n      pathExists.handlers.push({\n        method: route.method,\n        opts: route.opts.constraints || undefined,\n        meta: opts.includeMeta ? buildMetaObject.call(this, route, opts.includeMeta) : null\n      })\n      continue\n    }\n\n    const routeHandler = {\n      method: route.method,\n      opts: route.opts.constraints || undefined,\n      meta: opts.includeMeta ? buildMetaObject.call(this, route, opts.includeMeta) : null\n    }\n    mergedRouteArray.push({\n      path: route.path,\n      methods: [route.method],\n      opts: [route.opts],\n      handlers: [routeHandler]\n    })\n  }\n\n  // insert root level path if none defined\n  if (!mergedRouteArray.filter(r => r.path === pathDelimiter).length) {\n    const rootPath = {\n      path: pathDelimiter,\n      truncatedPath: '',\n      methods: [],\n      opts: [],\n      handlers: [{}]\n    }\n\n    // if wildcard route exists, insert root level after wildcard\n    if (mergedRouteArray.filter(r => r.path === wildcardDelimiter).length) {\n      mergedRouteArray.splice(1, 0, rootPath)\n    } else {\n      mergedRouteArray.unshift(rootPath)\n    }\n  }\n\n  // build tree\n  const routeTree = buildRouteTree(mergedRouteArray)\n\n  // draw tree\n  routeTree.forEach((rootBranch, idx) => {\n    tree += drawBranch(rootBranch, null, idx === routeTree.length - 1, false, true)\n    tree += '\\n' // newline characters inserted at beginning of drawing function to allow for nested paths\n  })\n\n  return tree\n}\n\nfunction buildRouteTree (mergedRouteArray) {\n  const result = []\n  const temp = { result }\n  mergedRouteArray.forEach((route, idx) => {\n    let splitPath = route.path.split(pathRegExp)\n\n    // add preceding slash for proper nesting\n    if (splitPath[0] !== pathDelimiter) {\n      // handle wildcard route\n      if (splitPath[0] !== wildcardDelimiter) splitPath = [pathDelimiter, splitPath[0].slice(1), ...splitPath.slice(1)]\n    }\n\n    // build tree\n    splitPath.reduce((acc, path, pidx) => {\n      if (!acc[path]) {\n        acc[path] = { result: [] }\n        const pathSeg = { path, children: acc[path].result }\n\n        if (pidx === splitPath.length - 1) pathSeg.handlers = route.handlers\n        acc.result.push(pathSeg)\n      }\n      return acc[path]\n    }, temp)\n  })\n\n  // unfold root object from array\n  return result\n}\n\nfunction drawBranch (pathSeg, prefix, endBranch, noPrefix, rootBranch) {\n  let branch = ''\n\n  if (!noPrefix && !rootBranch) branch += '\\n'\n  if (!noPrefix) branch += `${prefix || ''}${endBranch ? endBranchIndent : midBranchIndent}`\n  branch += `${pathSeg.path}`\n\n  if (pathSeg.handlers) {\n    const flatHandlers = pathSeg.handlers.reduce((acc, curr) => {\n      const match = acc.findIndex(h => JSON.stringify(h.opts) === JSON.stringify(curr.opts))\n      if (match !== -1) {\n        acc[match].method = [acc[match].method, curr.method].join(', ')\n      } else {\n        acc.push(curr)\n      }\n      return acc\n    }, [])\n\n    flatHandlers.forEach((handler, idx) => {\n      if (idx > 0) branch += `${noPrefix ? '' : prefix || ''}${endBranch ? indent : branchIndent}${pathSeg.path}`\n      branch += ` (${handler.method || '-'})`\n      if (handler.opts && JSON.stringify(handler.opts) !== '{}') branch += ` ${JSON.stringify(handler.opts)}`\n      if (handler.meta) {\n        Reflect.ownKeys(handler.meta).forEach((m, hidx) => {\n          branch += `\\n${noPrefix ? '' : prefix || ''}${endBranch ? indent : branchIndent}`\n          branch += `• (${m}) ${JSON.stringify(handler.meta[m])}`\n        })\n      }\n      if (flatHandlers.length > 1 && idx !== flatHandlers.length - 1) branch += '\\n'\n    })\n  } else {\n    if (pathSeg.children.length > 1) branch += ' (-)'\n  }\n\n  if (!noPrefix) prefix = `${prefix || ''}${endBranch ? indent : branchIndent}`\n\n  pathSeg.children.forEach((child, idx) => {\n    const endBranch = idx === pathSeg.children.length - 1\n    const skipPrefix = (!pathSeg.handlers && pathSeg.children.length === 1)\n    branch += drawBranch(child, prefix, endBranch, skipPrefix)\n  })\n\n  return branch\n}\n\nfunction prettyPrintFlattenedNode (flattenedNode, prefix, tail, opts) {\n  if (!this.buildPrettyMeta) throw new Error('buildPrettyMeta not defined')\n  opts.includeMeta = opts.includeMeta || null // array of meta items to display\n  let paramName = ''\n  const printHandlers = []\n\n  for (const { node, method } of flattenedNode.nodes) {\n    for (const handler of node.handlerStorage.handlers) {\n      printHandlers.push({ method, ...handler })\n    }\n  }\n\n  if (printHandlers.length) {\n    printHandlers.forEach((handler, index) => {\n      let suffix = `(${handler.method || '-'})`\n      if (Object.keys(handler.constraints).length > 0) {\n        suffix += ' ' + JSON.stringify(handler.constraints)\n      }\n\n      let name = ''\n      // find locations of parameters in prefix\n      const paramIndices = flattenedNode.prefix.split('').map((ch, idx) => ch === ':' ? idx : null).filter(idx => idx !== null)\n      if (paramIndices.length) {\n        let prevLoc = 0\n        paramIndices.forEach((loc, idx) => {\n          // find parameter in prefix\n          name += flattenedNode.prefix.slice(prevLoc, loc + 1)\n          // insert parameters\n          name += handler.params[handler.params.length - paramIndices.length + idx]\n          if (idx === paramIndices.length - 1) name += flattenedNode.prefix.slice(loc + 1)\n          prevLoc = loc + 1\n        })\n      } else {\n        // there are no parameters, return full object\n        name = flattenedNode.prefix\n      }\n\n      if (index === 0) {\n        paramName += `${name} ${suffix}`\n      } else {\n        paramName += `\\n${prefix}${tail ? indent : branchIndent}${name} ${suffix}`\n      }\n      if (opts.includeMeta) {\n        const meta = buildMetaObject.call(this, handler, opts.includeMeta)\n        Object.keys(meta).forEach((m, hidx) => {\n          paramName += `\\n${prefix || ''}${tail ? indent : branchIndent}`\n          paramName += `• (${m}) ${JSON.stringify(meta[m])}`\n        })\n      }\n    })\n  } else {\n    paramName = flattenedNode.prefix\n  }\n\n  let tree = `${prefix}${tail ? endBranchIndent : midBranchIndent}${paramName}\\n`\n\n  prefix = `${prefix}${tail ? indent : branchIndent}`\n  const labels = Object.keys(flattenedNode.children)\n  for (let i = 0; i < labels.length; i++) {\n    const child = flattenedNode.children[labels[i]]\n    tree += prettyPrintFlattenedNode.call(this, child, prefix, i === (labels.length - 1), opts)\n  }\n  return tree\n}\n\nfunction flattenNode (flattened, node, method) {\n  if (node.handlerStorage.handlers.length !== 0) {\n    flattened.nodes.push({ method, node })\n  }\n\n  if (node.parametricChildren && node.parametricChildren[0]) {\n    if (!flattened.children[':']) {\n      flattened.children[':'] = {\n        prefix: ':',\n        nodes: [],\n        children: {}\n      }\n    }\n    flattenNode(flattened.children[':'], node.parametricChildren[0], method)\n  }\n\n  if (node.wildcardChild) {\n    if (!flattened.children['*']) {\n      flattened.children['*'] = {\n        prefix: '*',\n        nodes: [],\n        children: {}\n      }\n    }\n    flattenNode(flattened.children['*'], node.wildcardChild, method)\n  }\n\n  if (node.staticChildren) {\n    for (const child of Object.values(node.staticChildren)) {\n      // split on the slash separator but use a regex to lookahead and not actually match it, preserving it in the returned string segments\n      const childPrefixSegments = child.prefix.split(pathRegExp)\n      let cursor = flattened\n      let parent\n      for (const segment of childPrefixSegments) {\n        parent = cursor\n        cursor = cursor.children[segment]\n        if (!cursor) {\n          cursor = {\n            prefix: segment,\n            nodes: [],\n            children: {}\n          }\n          parent.children[segment] = cursor\n        }\n      }\n      flattenNode(cursor, child, method)\n    }\n  }\n}\n\nfunction compressFlattenedNode (flattenedNode) {\n  const childKeys = Object.keys(flattenedNode.children)\n  if (flattenedNode.nodes.length === 0 && childKeys.length === 1) {\n    const child = flattenedNode.children[childKeys[0]]\n    if (child.nodes.length <= 1) {\n      compressFlattenedNode(child)\n      flattenedNode.nodes = child.nodes\n      flattenedNode.prefix += child.prefix\n      flattenedNode.children = child.children\n      return flattenedNode\n    }\n  }\n\n  for (const key of Object.keys(flattenedNode.children)) {\n    compressFlattenedNode(flattenedNode.children[key])\n  }\n\n  return flattenedNode\n}\n\nmodule.exports = { flattenNode, compressFlattenedNode, prettyPrintFlattenedNode, prettyPrintRoutesArray }\n","'use strict'\nconst assert = require('assert')\n\nfunction HostStorage () {\n  const hosts = {}\n  const regexHosts = []\n  return {\n    get: (host) => {\n      const exact = hosts[host]\n      if (exact) {\n        return exact\n      }\n      for (const regex of regexHosts) {\n        if (regex.host.test(host)) {\n          return regex.value\n        }\n      }\n    },\n    set: (host, value) => {\n      if (host instanceof RegExp) {\n        regexHosts.push({ host, value })\n      } else {\n        hosts[host] = value\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  name: 'host',\n  mustMatchWhenDerived: false,\n  storage: HostStorage,\n  validate (value) {\n    assert(typeof value === 'string' || Object.prototype.toString.call(value) === '[object RegExp]', 'Host should be a string or a RegExp')\n  }\n}\n","'use strict'\n\nconst assert = require('assert')\n\nfunction SemVerStore () {\n  if (!(this instanceof SemVerStore)) {\n    return new SemVerStore()\n  }\n\n  this.store = {}\n\n  this.maxMajor = 0\n  this.maxMinors = {}\n  this.maxPatches = {}\n}\n\nSemVerStore.prototype.set = function (version, store) {\n  if (typeof version !== 'string') {\n    throw new TypeError('Version should be a string')\n  }\n  let [major, minor, patch] = version.split('.')\n\n  major = Number(major) || 0\n  minor = Number(minor) || 0\n  patch = Number(patch) || 0\n\n  if (major >= this.maxMajor) {\n    this.maxMajor = major\n    this.store.x = store\n    this.store['*'] = store\n    this.store['x.x'] = store\n    this.store['x.x.x'] = store\n  }\n\n  if (minor >= (this.maxMinors[major] || 0)) {\n    this.maxMinors[major] = minor\n    this.store[`${major}.x`] = store\n    this.store[`${major}.x.x`] = store\n  }\n\n  if (patch >= (this.store[`${major}.${minor}`] || 0)) {\n    this.maxPatches[`${major}.${minor}`] = patch\n    this.store[`${major}.${minor}.x`] = store\n  }\n\n  this.store[`${major}.${minor}.${patch}`] = store\n  return this\n}\n\nSemVerStore.prototype.get = function (version) {\n  return this.store[version]\n}\n\nmodule.exports = {\n  name: 'version',\n  mustMatchWhenDerived: true,\n  storage: SemVerStore,\n  validate (value) {\n    assert(typeof value === 'string', 'Version should be a string')\n  }\n}\n","'use strict'\n\n// It must spot all the chars where decodeURIComponent(x) !== decodeURI(x)\n// The chars are: # $ & + , / : ; = ? @\nfunction decodeComponentChar (highCharCode, lowCharCode) {\n  if (highCharCode === 50) {\n    if (lowCharCode === 53) return '%'\n\n    if (lowCharCode === 51) return '#'\n    if (lowCharCode === 52) return '$'\n    if (lowCharCode === 54) return '&'\n    if (lowCharCode === 66) return '+'\n    if (lowCharCode === 98) return '+'\n    if (lowCharCode === 67) return ','\n    if (lowCharCode === 99) return ','\n    if (lowCharCode === 70) return '/'\n    if (lowCharCode === 102) return '/'\n    return null\n  }\n  if (highCharCode === 51) {\n    if (lowCharCode === 65) return ':'\n    if (lowCharCode === 97) return ':'\n    if (lowCharCode === 66) return ';'\n    if (lowCharCode === 98) return ';'\n    if (lowCharCode === 68) return '='\n    if (lowCharCode === 100) return '='\n    if (lowCharCode === 70) return '?'\n    if (lowCharCode === 102) return '?'\n    return null\n  }\n  if (highCharCode === 52 && lowCharCode === 48) {\n    return '@'\n  }\n  return null\n}\n\nfunction safeDecodeURI (path) {\n  let shouldDecode = false\n  let shouldDecodeParam = false\n\n  let querystring = ''\n\n  for (let i = 1; i < path.length; i++) {\n    const charCode = path.charCodeAt(i)\n\n    if (charCode === 37) {\n      const highCharCode = path.charCodeAt(i + 1)\n      const lowCharCode = path.charCodeAt(i + 2)\n\n      if (decodeComponentChar(highCharCode, lowCharCode) === null) {\n        shouldDecode = true\n      } else {\n        shouldDecodeParam = true\n        // %25 - encoded % char. We need to encode one more time to prevent double decoding\n        if (highCharCode === 50 && lowCharCode === 53) {\n          shouldDecode = true\n          path = path.slice(0, i + 1) + '25' + path.slice(i + 1)\n          i += 2\n        }\n        i += 2\n      }\n    // Some systems do not follow RFC and separate the path and query\n    // string with a `;` character (code 59), e.g. `/foo;jsessionid=123456`.\n    // Thus, we need to split on `;` as well as `?` and `#`.\n    } else if (charCode === 63 || charCode === 59 || charCode === 35) {\n      querystring = path.slice(i + 1)\n      path = path.slice(0, i)\n      break\n    }\n  }\n  const decodedPath = shouldDecode ? decodeURI(path) : path\n  return { path: decodedPath, querystring, shouldDecodeParam }\n}\n\nfunction safeDecodeURIComponent (uriComponent) {\n  const startIndex = uriComponent.indexOf('%')\n  if (startIndex === -1) return uriComponent\n\n  let decoded = ''\n  let lastIndex = startIndex\n\n  for (let i = startIndex; i < uriComponent.length; i++) {\n    if (uriComponent.charCodeAt(i) === 37) {\n      const highCharCode = uriComponent.charCodeAt(i + 1)\n      const lowCharCode = uriComponent.charCodeAt(i + 2)\n\n      const decodedChar = decodeComponentChar(highCharCode, lowCharCode)\n      decoded += uriComponent.slice(lastIndex, i) + decodedChar\n\n      lastIndex = i + 3\n    }\n  }\n  return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex)\n}\n\nmodule.exports = { safeDecodeURI, safeDecodeURIComponent }\n","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","class OratorServiceServerBase\n{\n\tconstructor(pOrator)\n\t{\n\t\tthis.orator = pOrator;\n\n\t\tthis.log = pOrator.log;\n\n\t\tthis.Name = this.orator.settings.Product;\n\t\tthis.URL = 'BASE_SERVICE_SERVER';\n\t\tthis.Port = this.orator.settings.ServicePort;\n\n\t\tthis.Active = false;\n\t}\n\n\t/*\n\t * Service Lifecycle Functions\n\t *************************************************************************/\n\tlisten(pPort, fCallback)\n\t{\n\t\t// Sometimes, listen does not listen on network calls.\n\t\tthis.Active = true;\n\n\t\treturn fCallback();\n\t}\n\n\tclose(fCallback)\n\t{\n\t\tthis.Active = false;\n\n\t\treturn fCallback();\n\t}\n\t/*************************************************************************\n\t * End of Service Lifecycle Functions\n\t */\n\n\n\t/*\n\t * Service Route Creation Functions\n\t *\n\t * These base functions provide basic validation for the routes, but don't actually \n\t * do anything with them.  The design intent here is to allow derived classes to call\n\t * these functions to validate that they conform to expected standards.\n\t *\n\t * Something like:\n\n\t\tget (pRoute, ...fRouteProcessingFunctions)\n\t\t{\n\t\t\tif (!super.get(pRoute, ...fRouteProcessingFunctions))\n\t\t\t{\n\t\t\t\tthis.log.error(`Restify provider failed to map route [${pRoute}]!`);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t//...now we can do our actual get mapping function!....\n\t\t}\n\n\t * This pattern and calling super is totally optional, obviously.\n\t *************************************************************************/\n\tget(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (typeof(pRoute) != 'string')\n\t\t{\n\t\t\tthis.log.error(`Orator GET Route mapping failed -- route parameter was ${typeof(pRoute)} instead of a string.`)\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tput(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (typeof(pRoute) != 'string')\n\t\t{\n\t\t\tthis.log.error(`Orator PUT Route mapping failed -- route parameter was ${typeof(pRoute)} instead of a string.`)\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpost(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (typeof(pRoute) != 'string')\n\t\t{\n\t\t\tthis.log.error(`Orator POST Route mapping failed -- route parameter was ${typeof(pRoute)} instead of a string.`)\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tdel(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (typeof(pRoute) != 'string')\n\t\t{\n\t\t\tthis.log.error(`Orator DEL Route mapping failed -- route parameter was ${typeof(pRoute)} instead of a string.`)\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpatch(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (typeof(pRoute) != 'string')\n\t\t{\n\t\t\tthis.log.error(`Orator PATCH Route mapping failed -- route parameter was ${typeof(pRoute)} instead of a string.`)\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\topts(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (typeof(pRoute) != 'string')\n\t\t{\n\t\t\tthis.log.error(`Orator OPTS Route mapping failed -- route parameter was ${typeof(pRoute)} instead of a string.`)\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\thead(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (typeof(pRoute) != 'string')\n\t\t{\n\t\t\tthis.log.error(`Orator HEAD Route mapping failed -- route parameter was ${typeof(pRoute)} instead of a string.`)\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\t/*************************************************************************\n\t * End of Service Route Creation Functions\n\t */\n\n\t// Programmatically invoke a route\n\tinvoke(pMethod, pRoute, pData, fCallback)\n\t{\n\t\t// The base class version of this does nothing\n\t\tthis.log.debug(`Orator invoke called for route [${pRoute}] and landed on the base class; the service provider likely does not implement programmatic invoke capabilities.`, pData);\n\t\treturn false;\n\t}\n}\n\nmodule.exports = OratorServiceServerBase;","/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\t\t\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\t\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\t\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t}\n}\n\nmodule.exports = Precedent;\n","/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\t\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\t\t\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\t\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\t\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\t\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) && \n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)));\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t */\n\tparseString (pString, pParseTree)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t}\n\t\t\n\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n","/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - The index of the character in the pattern\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {number} pParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","'use strict'\n\nvar parse = require('ret')\nvar types = parse.types\n\nmodule.exports = function (re, opts) {\n  if (!opts) opts = {}\n  var replimit = opts.limit === undefined ? 25 : opts.limit\n\n  if (isRegExp(re)) re = re.source\n  else if (typeof re !== 'string') re = String(re)\n\n  try { re = parse(re) } catch (err) { return false }\n\n  var reps = 0\n  return (function walk (node, starHeight) {\n    var i\n    var ok\n    var len\n\n    if (node.type === types.REPETITION) {\n      starHeight++\n      reps++\n      if (starHeight > 1) return false\n      if (reps > replimit) return false\n    }\n\n    if (node.options) {\n      for (i = 0, len = node.options.length; i < len; i++) {\n        ok = walk({ stack: node.options[i] }, starHeight)\n        if (!ok) return false\n      }\n    }\n    var stack = node.stack || (node.value && node.value.stack)\n    if (!stack) return true\n\n    for (i = 0; i < stack.length; i++) {\n      ok = walk(stack[i], starHeight)\n      if (!ok) return false\n    }\n\n    return true\n  })(re, 0)\n}\n\nfunction isRegExp (x) {\n  return {}.toString.call(x) === '[object RegExp]'\n}\n","const util      = require('./util');\nconst types     = require('./types');\nconst sets      = require('./sets');\nconst positions = require('./positions');\n\n\nmodule.exports = (regexpStr) => {\n  var i = 0, l, c,\n    start = { type: types.ROOT, stack: []},\n\n    // Keep track of last clause/group and stack.\n    lastGroup = start,\n    last = start.stack,\n    groupStack = [];\n\n\n  var repeatErr = (i) => {\n    util.error(regexpStr, `Nothing to repeat at column ${i - 1}`);\n  };\n\n  // Decode a few escaped characters.\n  var str = util.strToChars(regexpStr);\n  l = str.length;\n\n  // Iterate through each character in string.\n  while (i < l) {\n    c = str[i++];\n\n    switch (c) {\n      // Handle escaped characters, inclues a few sets.\n      case '\\\\':\n        c = str[i++];\n\n        switch (c) {\n          case 'b':\n            last.push(positions.wordBoundary());\n            break;\n\n          case 'B':\n            last.push(positions.nonWordBoundary());\n            break;\n\n          case 'w':\n            last.push(sets.words());\n            break;\n\n          case 'W':\n            last.push(sets.notWords());\n            break;\n\n          case 'd':\n            last.push(sets.ints());\n            break;\n\n          case 'D':\n            last.push(sets.notInts());\n            break;\n\n          case 's':\n            last.push(sets.whitespace());\n            break;\n\n          case 'S':\n            last.push(sets.notWhitespace());\n            break;\n\n          default:\n            // Check if c is integer.\n            // In which case it's a reference.\n            if (/\\d/.test(c)) {\n              last.push({ type: types.REFERENCE, value: parseInt(c, 10) });\n\n            // Escaped character.\n            } else {\n              last.push({ type: types.CHAR, value: c.charCodeAt(0) });\n            }\n        }\n\n        break;\n\n\n      // Positionals.\n      case '^':\n        last.push(positions.begin());\n        break;\n\n      case '$':\n        last.push(positions.end());\n        break;\n\n\n      // Handle custom sets.\n      case '[':\n        // Check if this class is 'anti' i.e. [^abc].\n        var not;\n        if (str[i] === '^') {\n          not = true;\n          i++;\n        } else {\n          not = false;\n        }\n\n        // Get all the characters in class.\n        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);\n\n        // Increase index by length of class.\n        i += classTokens[1];\n        last.push({\n          type: types.SET,\n          set: classTokens[0],\n          not,\n        });\n\n        break;\n\n\n      // Class of any character except \\n.\n      case '.':\n        last.push(sets.anyChar());\n        break;\n\n\n      // Push group onto stack.\n      case '(':\n        // Create group.\n        var group = {\n          type: types.GROUP,\n          stack: [],\n          remember: true,\n        };\n\n        c = str[i];\n\n        // If if this is a special kind of group.\n        if (c === '?') {\n          c = str[i + 1];\n          i += 2;\n\n          // Match if followed by.\n          if (c === '=') {\n            group.followedBy = true;\n\n          // Match if not followed by.\n          } else if (c === '!') {\n            group.notFollowedBy = true;\n\n          } else if (c !== ':') {\n            util.error(regexpStr,\n              `Invalid group, character '${c}'` +\n              ` after '?' at column ${i - 1}`);\n          }\n\n          group.remember = false;\n        }\n\n        // Insert subgroup into current group stack.\n        last.push(group);\n\n        // Remember the current group for when the group closes.\n        groupStack.push(lastGroup);\n\n        // Make this new group the current group.\n        lastGroup = group;\n        last = group.stack;\n        break;\n\n\n      // Pop group out of stack.\n      case ')':\n        if (groupStack.length === 0) {\n          util.error(regexpStr, `Unmatched ) at column ${i - 1}`);\n        }\n        lastGroup = groupStack.pop();\n\n        // Check if this group has a PIPE.\n        // To get back the correct last stack.\n        last = lastGroup.options ?\n          lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;\n        break;\n\n\n      // Use pipe character to give more choices.\n      case '|':\n        // Create array where options are if this is the first PIPE\n        // in this clause.\n        if (!lastGroup.options) {\n          lastGroup.options = [lastGroup.stack];\n          delete lastGroup.stack;\n        }\n\n        // Create a new stack and add to options for rest of clause.\n        var stack = [];\n        lastGroup.options.push(stack);\n        last = stack;\n        break;\n\n\n      // Repetition.\n      // For every repetition, remove last element from last stack\n      // then insert back a RANGE object.\n      // This design is chosen because there could be more than\n      // one repetition symbols in a regex i.e. `a?+{2,3}`.\n      case '{':\n        var rs = /^(\\d+)(,(\\d+)?)?\\}/.exec(str.slice(i)), min, max;\n        if (rs !== null) {\n          if (last.length === 0) {\n            repeatErr(i);\n          }\n          min = parseInt(rs[1], 10);\n          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;\n          i += rs[0].length;\n\n          last.push({\n            type: types.REPETITION,\n            min,\n            max,\n            value: last.pop(),\n          });\n        } else {\n          last.push({\n            type: types.CHAR,\n            value: 123,\n          });\n        }\n        break;\n\n      case '?':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: 1,\n          value: last.pop(),\n        });\n        break;\n\n      case '+':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 1,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n      case '*':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n\n      // Default is a character that is not `\\[](){}?+*^$`.\n      default:\n        last.push({\n          type: types.CHAR,\n          value: c.charCodeAt(0),\n        });\n    }\n\n  }\n\n  // Check if any groups have not been closed.\n  if (groupStack.length !== 0) {\n    util.error(regexpStr, 'Unterminated group');\n  }\n\n  return start;\n};\n\nmodule.exports.types = types;\n","const types = require('./types');\nexports.wordBoundary = () => ({ type: types.POSITION, value: 'b' });\nexports.nonWordBoundary = () => ({ type: types.POSITION, value: 'B' });\nexports.begin = () => ({ type: types.POSITION, value: '^' });\nexports.end = () => ({ type: types.POSITION, value: '$' });\n","const types = require('./types');\n\nconst INTS = () => [{ type: types.RANGE , from: 48, to: 57 }];\n\nconst WORDS = () => {\n  return [\n    { type: types.CHAR, value: 95 },\n    { type: types.RANGE, from: 97, to: 122 },\n    { type: types.RANGE, from: 65, to: 90 }\n  ].concat(INTS());\n};\n\nconst WHITESPACE = () => {\n  return [\n    { type: types.CHAR, value: 9 },\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 11 },\n    { type: types.CHAR, value: 12 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 32 },\n    { type: types.CHAR, value: 160 },\n    { type: types.CHAR, value: 5760 },\n    { type: types.RANGE, from: 8192, to: 8202 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n    { type: types.CHAR, value: 8239 },\n    { type: types.CHAR, value: 8287 },\n    { type: types.CHAR, value: 12288 },\n    { type: types.CHAR, value: 65279 }\n  ];\n};\n\nconst NOTANYCHAR = () => {\n  return [\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n  ];\n};\n\n// Predefined class objects.\nexports.words = () => ({ type: types.SET, set: WORDS(), not: false });\nexports.notWords = () => ({ type: types.SET, set: WORDS(), not: true });\nexports.ints = () => ({ type: types.SET, set: INTS(), not: false });\nexports.notInts = () => ({ type: types.SET, set: INTS(), not: true });\nexports.whitespace = () => ({ type: types.SET, set: WHITESPACE(), not: false });\nexports.notWhitespace = () => ({ type: types.SET, set: WHITESPACE(), not: true });\nexports.anyChar = () => ({ type: types.SET, set: NOTANYCHAR(), not: true });\n","module.exports = {\n  ROOT       : 0,\n  GROUP      : 1,\n  POSITION   : 2,\n  SET        : 3,\n  RANGE      : 4,\n  REPETITION : 5,\n  REFERENCE  : 6,\n  CHAR       : 7,\n};\n","const types = require('./types');\nconst sets  = require('./sets');\n\n\nconst CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^ ?';\nconst SLSH = { '0': 0, 't': 9, 'n': 10, 'v': 11, 'f': 12, 'r': 13 };\n\n/**\n * Finds character representations in str and convert all to\n * their respective characters\n *\n * @param {String} str\n * @return {String}\n */\nexports.strToChars = function(str) {\n  /* jshint maxlen: false */\n  var chars_regex = /(\\[\\\\b\\])|(\\\\)?\\\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\\\\]^?])|([0tnvfr]))/g;\n  str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {\n    if (lbs) {\n      return s;\n    }\n\n    var code = b ? 8 :\n      a16   ? parseInt(a16, 16) :\n      b16   ? parseInt(b16, 16) :\n      c8    ? parseInt(c8,   8) :\n      dctrl ? CTRL.indexOf(dctrl) :\n      SLSH[eslsh];\n\n    var c = String.fromCharCode(code);\n\n    // Escape special regex characters.\n    if (/[[\\]{}^$.|?*+()]/.test(c)) {\n      c = '\\\\' + c;\n    }\n\n    return c;\n  });\n\n  return str;\n};\n\n\n/**\n * turns class into tokens\n * reads str until it encounters a ] not preceeded by a \\\n *\n * @param {String} str\n * @param {String} regexpStr\n * @return {Array.<Array.<Object>, Number>}\n */\nexports.tokenizeClass = (str, regexpStr) => {\n  /* jshint maxlen: false */\n  var tokens = [];\n  var regexp = /\\\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\\\)(.)|([^\\]\\\\]))-(?:\\\\)?([^\\]]))|(\\])|(?:\\\\)?([^])/g;\n  var rs, c;\n\n\n  while ((rs = regexp.exec(str)) != null) {\n    if (rs[1]) {\n      tokens.push(sets.words());\n\n    } else if (rs[2]) {\n      tokens.push(sets.ints());\n\n    } else if (rs[3]) {\n      tokens.push(sets.whitespace());\n\n    } else if (rs[4]) {\n      tokens.push(sets.notWords());\n\n    } else if (rs[5]) {\n      tokens.push(sets.notInts());\n\n    } else if (rs[6]) {\n      tokens.push(sets.notWhitespace());\n\n    } else if (rs[7]) {\n      tokens.push({\n        type: types.RANGE,\n        from: (rs[8] || rs[9]).charCodeAt(0),\n        to: rs[10].charCodeAt(0),\n      });\n\n    } else if ((c = rs[12])) {\n      tokens.push({\n        type: types.CHAR,\n        value: c.charCodeAt(0),\n      });\n\n    } else {\n      return [tokens, regexp.lastIndex];\n    }\n  }\n\n  exports.error(regexpStr, 'Unterminated character class');\n};\n\n\n/**\n * Shortcut to throw errors.\n *\n * @param {String} regexp\n * @param {String} msg\n */\nexports.error = (regexp, msg) => {\n  throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);\n};\n","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};","/**\n* Simple browser shim loader - assign the npm module to a window global automatically\n*\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libNPMModuleWrapper = require('./Orator.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('Orator'))\n{\n\twindow.Orator = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;","// Simple default configuration for application, when none is provided\n\nmodule.exports = (\n{\n\t\"Product\": \"Unnamed_Service\",\n\t\"ProductVersion\": \"0.0.1\",\n\n\t\"ServicePort\": 8080\n});\n\n","/**\n* Default Service Server Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the servers that are available without extensions loaded\ngetDefaultServiceServers = () =>\n{\n\tlet tmpDefaultServiceServers = {};\n\n\ttmpDefaultServiceServers.ipc = require('./Orator-ServiceServer-IPC.js');\n\n\ttmpDefaultServiceServers.default = tmpDefaultServiceServers.ipc;\n\n\treturn tmpDefaultServiceServers;\n}\n\nmodule.exports = getDefaultServiceServers();","'use strict'\n\n// This is taken directly from the find-my-way documentation for custom constraints and only mildly edited\nconst ipcResponseTypeStrategy = (\n\t{\n\t\t// strategy name for referencing in the route handler `constraints` options\n\t\tname: 'ipc',\n\t\tisAsync: true,\n\n\t\t// storage factory for storing routes in the find-my-way route tree\n\t\tstorage:\n\t\t\t()=>\n\t\t\t{\n\t\t\t\tlet handlers = {};\n\n\t\t\t\treturn (\n\t\t\t\t\t{\n\t\t\t\t\t\tget: (type) => { return handlers[type] || null },\n\t\t\t\t\t\tset: (type, store) => { handlers[type] = store }\n\t\t\t\t\t});\n\t\t\t},\n\n\t\t// function to get the value of the constraint from each incoming request\n\t\tderiveConstraint: (pRequest, pContext, fDone) =>\n\t\t\t{\n\t\t\t\t// If we wanted to deny the IPC request based on a constraint, we would do:\n\t\t\t\t// fDone(new Error(`The request was denied because ____ in the Request object wasn't right...`));\n\t\t\t\treturn fDone(null, 'IPC');\n\t\t\t},\n\n\t\t// optional flag marking if handlers without constraints can match requests that have a value for this constraint\n\t\tmustMatchWhenDerived: true\n\t});\n\nmodule.exports = ipcResponseTypeStrategy;","class OratorServiceServerIPCSynthesizedResponse\n{\n\tconstructor(pLog, pRequestGUID)\n\t{\n\t\tthis.log = pLog;\n\n\t\tthis.requestGUID = pRequestGUID;\n\n\t\tthis.responseData = null;\n\t\tthis.responseStatus = -1;\n\t}\n\n\tsend(pData)\n\t{\n\t\tif (typeof(pData) == 'string')\n\t\t{\n\t\t\t// This is a string!  Append it to the responsedata.\n\t\t\tif (this.responseData === null)\n\t\t\t{\n\t\t\t\tthis.responseData = pData;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (typeof(this.responseData) == 'string')\n\t\t\t{\n\t\t\t\tthis.responseData = this.responseData+pData;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.log(`Request ${this.requestGUID} has tried to send() a string value after send()ing data type ${typeof(this.responseData)}.`, pData)\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (typeof(pData) == 'object')\n\t\t{\n\t\t\tif (this.responseData === null)\n\t\t\t{\n\t\t\t\tthis.responseData = JSON.stringify(pData);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (typeof(this.responseData) == 'string')\n\t\t\t{\n\t\t\t\t// TODO: Discuss best way to handle this / if to handle this\n\t\t\t\tthis.responseData += this.responseData+JSON.stringify(pData);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.log(`Request ${this.requestGUID} has tried to send() an object value to be auto stringified after send()ing data type ${typeof(this.responseData)}.`, pData)\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = OratorServiceServerIPCSynthesizedResponse;","const libOratorServiceServerBase = require('orator-serviceserver');\n\n// A synthesized response object, for simple IPC.\nconst libOratorServiceServerIPCSynthesizedResponse = require('./Orator-ServiceServer-IPC-SynthesizedResponse.js');\n// A simple constrainer for the find-my-way router since we aren't using any kind of headers to pass version or host\nconst libOratorServiceServerIPCCustomConstrainer = require('./Orator-ServiceServer-IPC-RouterConstrainer.js');\n\n// This library is the default router for our services\nconst libFindMyWay = require('find-my-way');\n//const libAsync = require('async');\nconst libAsyncWaterfall = require(\"async/waterfall\");\nconst libAsyncEachOfSeries = require('async/eachofseries')\n\nclass OratorServiceServerIPC extends libOratorServiceServerBase\n{\n\tconstructor(pOrator)\n\t{\n\t\tsuper(pOrator);\n\n\t\tthis.routerOptions = (this.orator.settings.hasOwnProperty('router_options') && (typeof(this.orator.settings.router_options) == 'object')) ? this.orator.settings.router_options : {};\n\t\tthis.router = libFindMyWay(this.routerOptions);\n\t\tthis.router.addConstraintStrategy(libOratorServiceServerIPCCustomConstrainer);\n\n\t\tthis.URL = 'IPC';\n\n\t\tthis.preBehaviorFunctions = [];\n\t\tthis.behaviorMap = {};\n\t\tthis.postBehaviorFunctions = [];\n\t}\n\n\texecutePreBehaviorFunctions(pRequest, pResponse, fNext)\n\t{\n\t\tlibAsyncEachOfSeries(this.preBehaviorFunctions,\n\t\t\t(fBehaviorFunction, pFunctionIndex, fCallback) =>\n\t\t\t{\n\t\t\t\treturn fBehaviorFunction(pRequest, pResponse, fCallback);\n\t\t\t},\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (pError)\n\t\t\t\t{\n\t\t\t\t\tthis.log.error(`IPC Provider preBehaviorFunction ${pFunctionIndex} failed with error: ${pError}`, pError);\n\t\t\t\t}\n\t\t\t\treturn fNext(pError);\n\t\t\t});\n\t}\n\n\texecutePostBehaviorFunctions(pRequest, pResponse, fNext)\n\t{\n\t\tlibAsyncEachOfSeries(this.postBehaviorFunctions,\n\t\t\t(fBehaviorFunction, pFunctionIndex, fCallback) =>\n\t\t\t{\n\t\t\t\treturn fBehaviorFunction(pRequest, pResponse, fCallback);\n\t\t\t},\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (pError)\n\t\t\t\t{\n\t\t\t\t\tthis.log.error(`IPC Provider postBehaviorFunction ${pFunctionIndex} failed with error: ${pError}`, pError);\n\t\t\t\t}\n\t\t\t\treturn fNext(pError);\n\t\t\t});\n\t}\n\n\t/*\n\t * Service Route Creation Functions\n\t *\n\t * These base functions provide basic validation for the routes, but don't actually \n\t * do anything with them.  The design intent here is to allow derived classes to call\n\t * these functions to validate that they conform to expected standards.\n\t *\n\t * Something like:\n\n\t\tget (pRoute, ...fRouteProcessingFunctions)\n\t\t{\n\t\t\t//...now we can do our actual get mapping function!....\n\t\t}\n\n\t * This pattern and calling super is totally optional, obviously.\n\t *************************************************************************/\n\taddRouteProcessor(pMethod, pRoute, pRouteFunctionArray)\n\t{\n\t\t// We have a constrainer on IPC so we can control channels eventually, if we like.\n\t\t// For now it just makes sure it was added with an IPC service server.\n\t\tthis.router.on(pMethod, pRoute, { constraints: { \"ipc\": \"IPC\" } },\n\t\t\t(pRequest, pResponse, pParameters) =>\n\t\t\t{\n\t\t\t\tlibAsyncWaterfall(\n\t\t\t\t\t[\n\t\t\t\t\t\t(fStageComplete)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Added to make this mimic what we saw with route parsing in the old restify\n\t\t\t\t\t\t\tpRequest.params = pParameters;\n\t\t\t\t\t\t\treturn fStageComplete();\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(fStageComplete)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.executePreBehaviorFunctions(pRequest, pResponse, fStageComplete);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(fStageComplete)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlibAsyncEachOfSeries(pRouteFunctionArray,\n\t\t\t\t\t\t\t\t(fBehaviorFunction, pFunctionIndex, fCallback) =>\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\treturn fBehaviorFunction(pRequest, pResponse, fCallback);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t(pBehaviorFunctionError) =>\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (pBehaviorFunctionError)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tthis.log.error(`IPC Provider behavior function ${pFunctionIndex} failed with error: ${pBehaviorFunctionError}`, pBehaviorFunctionError);\n\t\t\t\t\t\t\t\t\t\treturn fNext(pError);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(fStageComplete)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.executePostBehaviorFunctions(pRequest, pResponse, fStageComplete);\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t(pRequestError)=>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pRequestError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.log.error(`IPC Provider behavior function ${pFunctionIndex} failed with error: ${pBehaviorFunctionError}`, pBehaviorFunctionError);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t});\n\n\t\treturn true;\n\t}\n\n\tget(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (!super.get(pRoute, ...fRouteProcessingFunctions))\n\t\t{\n\t\t\tthis.log.error(`IPC provider failed to map GET route [${pRoute}]!`);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.addRouteProcessor('GET', pRoute, Array.from(fRouteProcessingFunctions));\n\t}\n\n\tput(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (!super.get(pRoute, ...fRouteProcessingFunctions))\n\t\t{\n\t\t\tthis.log.error(`IPC provider failed to map PUT route [${pRoute}]!`);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpost(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (!super.get(pRoute, ...fRouteProcessingFunctions))\n\t\t{\n\t\t\tthis.log.error(`IPC provider failed to map POST route [${pRoute}]!`);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tdel(pRoute, ...fRouteProcessingFunctions)\n\t{\n\t\tif (!super.get(pRoute, ...fRouteProcessingFunctions))\n\t\t{\n\t\t\tthis.log.error(`IPC provider failed to map DEL route [${pRoute}]!`);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\t/*************************************************************************\n\t * End of Service Route Creation Functions\n\t */\n\n\t// Programmatically invoke a route\n\tinvoke(pMethod, pRoute, pData, fCallback)\n\t{\n\t\t// If the data is skipped and a callback is parameter 3, do the right thing\n\t\tlet tmpCallback = (typeof(fCallback) == 'function') ? fCallback : \n\t\t\t\t\t\t\t(typeof(pData) == 'function') ? pData :\n\t\t\t\t\t\t\t// This is here in case the developer passed no callback and just wants to fire and forget the IPC call which might not be async safe\n\t\t\t\t\t\t\t()=>{};\n\n\t\t// Create a bare minimum request object for IPC to pass to our router\n\t\tlet tmpRequest = (\n\t\t\t{\n\t\t\t\tmethod: pMethod,\n\t\t\t\turl: pRoute,\n\t\t\t\tguid: this.orator.fable.getUUID()\n\t\t\t});\n\n\t\t// Create a container for the IPC response data to be aggregated to from send() methodds\n\t\tlet tmpSynthesizedResponseData = new libOratorServiceServerIPCSynthesizedResponse(this.log, tmpRequest.guid);\n\n\t\treturn this.router.lookup(\n\t\t\ttmpRequest,\n\t\t\ttmpSynthesizedResponseData,\n\t\t\t(pError, pResults)=>\n\t\t\t{\n\t\t\t\tif (pError)\n\t\t\t\t{\n\t\t\t\t\tthis.log.error(`IPC Request Error Request GUID [${tmpRequest.guid}] handling route [${pRoute}]: ${pError}`, {Error: pError, Route: pRoute, Data: pData});\n\t\t\t\t}\n\n\t\t\t\t// by default, send data back through \n\t\t\t\treturn tmpCallback(pError, tmpSynthesizedResponseData.responseData, tmpSynthesizedResponseData, pResults);\n\t\t\t});\n\t}\n}\n\nmodule.exports = OratorServiceServerIPC;","/**\n* Orator Service Abstraction\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Orator Service\n*/\n\nconst libFable = require('fable');\n\nconst defaultOratorConfiguration = require('./Orator-Default-Configuration.js');\nconst defaultOratorServiceServers = require('./Orator-Default-ServiceServers-Node.js');\n\nclass Orator\n{\n\tconstructor(pFable, pServiceProvider)\n\t{\n\t\t// Need to figure out if pFable is a Fable object or a Settings object or neither\n\t\tif ((typeof(pFable) === 'object') && (pFable instanceof libFable))\n\t\t{\n\t\t\t// We were passed a fully operational fable -- use this\n\t\t\tthis.fable = pFable;\n\t\t}\n\t\telse if (typeof(pFable) == 'object')\n\t\t{\n\t\t\tthis.fable = new libFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = new libFable(defaultOratorConfiguration);\n\t\t}\n\n\t\t// Carry core application requirements into the orator object for simplicity\n\t\tthis.settings = this.fable.settings;\n\t\tthis.log = this.fable.log;\n\n\t\t// Create the empty, important logic containers\n\t\tthis.serviceServer = false;\n\t\tthis.serviceServerProvider = false;\n\n\t\tif (typeof(pServiceProvider) !== 'undefined')\n\t\t{\n\t\t\tthis.serviceServerProvider = pServiceProvider;\n\t\t}\n\n\t\t// Now check to see that the ServicePort is set (this used to be APIServerPort)\n\t\tif (!this.settings.hasOwnProperty('ServicePort'))\n\t\t{\n\t\t\tif (this.settings.hasOwnProperty('APIServerPort'))\n\t\t\t{\n\t\t\t\t// Automatically migrate the legacy APIServerPort to ServicePort\n\t\t\t\tthis.settings.ServicePort = this.fable.settings.APIServerPort;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Default to whatever the ... default is!\n\t\t\t\tthis.settings.ServicePort = defaultOratorConfiguration.ServicePort;\n\t\t\t}\n\t\t}\n\n\t\t// Now check to see that the Product name is set\n\t\tif (!this.settings.hasOwnProperty('Product'))\n\t\t{\n\t\t\tthis.settings.Product = defaultOratorConfiguration.Product;\n\t\t}\n\t}\n\n\tinitializeServiceServer(fNext)\n\t{\n\t\tvar tmpNext = (typeof(fNext) === 'function') ? fNext : ()=>{};\n\n\t\tif (!this.serviceServer)\n\t\t{\n\t\t\t// If the developer hasn't set this to a service provider class of their own choosing, \n\t\t\t// use the built-in network-less one.\n\t\t\tif (!this.serviceServerProvider)\n\t\t\t{\n\t\t\t\tthis.serviceServerProvider = defaultOratorServiceServers.default;\n\t\t\t}\n\n\t\t\tthis.serviceServer = new this.serviceServerProvider(this);\n\n\t\t\t// For legacy reasons, we also will provide this under the \"webServer\" variable.\n\t\t\tthis.webServer = this.serviceServer;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`Orator attempting to initialize a service server after initialization has already completed.`)\n\t\t}\n\t}\n\n\t_startServiceListener(fNext)\n\t{\n\t\treturn this.serviceServer.listen\n\t\t(\n\t\t\tthis.settings.ServicePort,\n\t\t\t(pError)\t=>\n\t\t\t{\n\t\t\t\tthis.log.info(`${this.serviceServer.Name} listening at ${this.serviceServer.URL} port ${this.serviceServer.Port}`);\n\t\t\t\treturn fNext(pError);\n\t\t\t}\n\t\t);\n\t}\n\n\tstartService(fNext)\n\t{\n\t\tvar tmpNext = (typeof(fNext) === 'function') ? fNext : ()=>{};\n\n\t\tif (!this.serviceServer)\n\t\t{\n\t\t\tthis.initializeServiceServer();\n\t\t}\n\n\t\treturn this._startServiceListener(tmpNext);\n\t}\n\n\tstopService(fNext)\n\t{\n\t\tvar tmpNext = (typeof(fNext) === 'function') ? fNext : ()=>{};\n\n\t\tif (!this.serviceServer)\n\t\t{\n\t\t\tlet tmpMessage = `Orator attempting to stop a service server but the service server has not been intialized yet.`;\n\t\t\tthis.log.warn(tmpMessage);\n\t\t\treturn tmpNext(tmpMessage);\n\t\t}\n\n\t\tif (!this.serviceServer.Active)\n\t\t{\n\t\t\tlet tmpMessage = `Orator attempting to stop a service server but the service server is not actively running.`;\n\t\t\tthis.log.warn(tmpMessage);\n\t\t\treturn tmpNext(tmpMessage);\n\t\t}\n\n\t\treturn this.serviceServer.close(tmpNext);\n\t}\n\n\tinvoke(pMethod, pRoute, pData, fCallback)\n\t{\n\t\treturn this.serviceServer.invoke(pMethod, pRoute, pData, fCallback);\n\t}\n\n\n\t/*\n\t * Legacy Orator Functions\n\t *************************************************************************/\n\tstartWebServer(fNext)\n\t{\n\t\treturn this.startService(fNext);\n\t}\n\n\t// For legacy purposes\n\tstopWebServer(fNext)\n\t{\n\t\treturn this.stopService(fNext);\n\t}\n\n\t// For legacy purposes\n\tgetWebServer()\n\t{\n\t\t// The old behavior was to lazily construct the service the first time \n\t\t// this accessor function is called.\n\t\tif (!this.serviceServer)\n\t\t{\n\t\t\tthis.initializeServiceServer();\n\t\t}\n\n\t\treturn this.serviceServer;\n\t}\n\t/*************************************************************************\n\t * End of Legacy Orator Functions\n\t */\n}\n\nmodule.exports = Orator;\n"]}